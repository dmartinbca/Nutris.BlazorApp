@* -------------------------------------------------------------
   BoteCapDataModal.razor — modal lateral derecho responsive
   ------------------------------------------------------------- *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using System.Collections.Generic
@using System.Linq
@using NutrisBlazor.Services
@using Nutris.BlazorApp.Components.Shared.Bote
@using Nutris.BlazorApp.Components.Shared.Cover
@using NutrisBlazor.Components.Shared
@using System.Text.Json
@inject HttpClient Http
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject ILogger<BoteCapDataModal> Logger

<link href="/css/BoteCapDataModal.css" rel="stylesheet" />
<link href="/css/fonts.css" rel="stylesheet" />

@if (IsVisible)
{
    <!-- Backdrop -->
    <div class="modal-backdrop-custom" @onclick="HideModal"></div>

    <!-- Modal Container -->
    <div class="modal-custom show">
        <div class="modal-dialog-custom">
            <div class="modal-content-custom">

                <!-- Header -->
                <div class="modal-header">
                    <h2 class="modal-title">Packaging/Envasado</h2>
                    <button type="button" class="btn-close" @onclick="HideModal">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>

                <!-- Body que contiene TODO -->
                <div class="modal-body">
                    <!-- Contenedor wrapper para tabs y botón reset -->
                    <div class="tabs-wrapper">
                        <div class="custom-tabs">
                            <button class="nav-link @(IsBottleTab ? "active bottle-tab" : "")"
                                    @onclick="() => SwitchToBottleTab()">
                                @Localization["modalContainer.Bottle"]
                            </button>
                            <button class="nav-link @(!IsBottleTab ? "active cap-tab" : "")"
                                    @onclick="() => SwitchToCapTab()">
                                @Localization["modalContainer.CAP"]
                            </button>
                        </div>
                        <button class="reset-filters-btn" @onclick="ResetFilters">
                            <img src="img/refresh.svg" alt="" aria-hidden="true" />
                            @Localization["modalContainer.Resetfilter"]
                        </button>
                    </div>

                    <!-- Contenido directamente después de las tabs -->
                    @if (IsBottleTab)
                    {
                        <!-- BOTE TAB -->
                        <div class="config-container">
                            <div class="preview-section">
                                <h3 class="section-title">
                                    @Localization["modalContainer.Characteristics"]
                                </h3>
                                @if (!string.IsNullOrEmpty(PesoTotal) && !CapacidadOptionsFiltered.Any())
                                {
                                    <div class="alert alert-warning" style="margin: 10px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 5px;">
                                        <strong> @Localization["Atention"]:</strong> @Localization["AtentionMsg"]
                                    </div>
                                }
                                <div class="preview-content">
                                    <div class="bottle-visual-wrapper" data-size="@BoteConfig.Capacidad">
                                        <div class="dimension-lines-container" id="dimension-lines-@(ComponentId)">
                                            @* Dimensión superior (diámetro de boca) *@
                                            <div class="dimension-top">
                                                <span class="dimension-text">@GetDiamBocaText()</span>
                                            </div>

                                            @* Dimensión izquierda (altura) - se ajustará dinámicamente *@
                                            <div class="dimension-left" id="dim-left-@(ComponentId)">
                                                <span class="dimension-text">@GetAlturaText()</span>
                                            </div>

                                            @* Dimensión inferior (diámetro base) *@
                                            <div class="dimension-bottom">
                                                <span class="dimension-text">@GetDiamBaseText()</span>
                                            </div>
                                        </div>

                                        <!-- Botella según forma -->
                                        <div class="bottle-svg-container" id="bottle-container-@(ComponentId)">
                                            @if (!string.IsNullOrEmpty(BoteConfig.ImagenBote))
                                            {
                                                <img src="@BoteConfig.ImagenBote"
                                                     alt="Imagen del bote"
                                                     loading="lazy"
                                                     @onload="OnImageLoaded" />
                                            }
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <!-- Forma -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Shape"]</label>
@*                                     <div class="segmented">
                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "ROUND" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("ROUND"))"
                                                @onclick='() => SetFormaBote("ROUND")'>
                                            <span class="radio-icon"></span> Round
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "SQUARE" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("SQUARE"))"
                                                @onclick='() => SetFormaBote("SQUARE")'>
                                            <span class="radio-icon"></span> Square
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "CYLINDRICAL" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("CYLINDRICAL"))"
                                                @onclick='() => SetFormaBote("CYLINDRICAL")'>
                                            <span class="radio-icon"></span> Cylindrical
                                        </button>
                                    </div> *@
                                    <!-- FORMAS DE BOTE - DINÁMICO -->
                                    <div class="segmented">
                                        @foreach (var forma in GetAvailableBottleShapes())
                                        {
                                            <button type="button"
                                                    class="segmented-item @(IsBottleShapeSelected(forma.Key) ? "active" : "")"
                                                    @onclick="() => OnBottleShapeChange(forma.Key)"
                                                    disabled="@IsSaving">
                                                <span class="radio-icon"></span>
                                                @forma.Value
                                            </button>
                                        }
                                    </div>
                                </div>

                                <!-- Tamaño -->
                                <div class="field">
                                    <label class="form-label">
                                        @Localization["modalContainer.Size"]
                                    </label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Capacidad"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectasize"]</option>
                                        @foreach (var cap in CapacidadOptionsFiltered)
                                        {
                                            <option value="@cap">@cap</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Diámetro -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Diameter"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Diametro"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectadiameter"]</option>
                                        @foreach (var d in DiametroOptionsFiltered)
                                        {
                                            <option value="@d">@d</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Material -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Material"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Material"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectmaterial"]</option>
                                        @foreach (var m in MaterialOptionsFiltered)
                                        {
                                            <option value="@m">@m</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Tipo (Color) -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Color"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Color"
                                                 @bind-Value:after="OnBoteColorChangedAsync">
                                        <option value="">@Localization["modalContainer.Selectacolor"]</option>
                                        @foreach (var c in OptionsColorBoteFiltered)
                                        {
                                            <option value="@(c.Label ?? c.Value)">@(c.Label ?? c.Value)</option>
                                        }
                                    </InputSelect>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <!-- TAPA TAB -->
                        <div class="config-container">
                            <div class="preview-section cap-preview">
                                <h3 class="section-title">@Localization["modalLabel.Characteristics"]</h3>

                                <div class="preview-content">
                                    <div class="cap-visual-wrapper" id="cap-wrapper-@(ComponentId)">
                                        @* Contenedor de líneas de dimensión *@
                                        <div class="cap-dimension-top">
                                            <span class="dimension-text">@GetCapDiameterText()</span>
                                        </div>

                                        <div class="cap-dimension-left">
                                            <span class="dimension-text">@GetCapHeightText()</span>
                                        </div>

                                        @if (!string.IsNullOrEmpty(CapConfig.ImagenCap))
                                        {
                                            <img src="@CapConfig.ImagenCap"
                                                 alt="Imagen de la tapa"
                                                 @onload="OnCapImageLoaded" />
                                        }
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <!-- Forma -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Shape"]</label>
@*                                     <div class="segmented">
                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "SIMPLE" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("SIMPLE"))"
                                                @onclick='() => SetFormaCap("SIMPLE")'>
                                            <span class="radio-icon"></span> Simple
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "METAL" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("METAL"))"
                                                @onclick='() => SetFormaCap("METAL")'>
                                            <span class="radio-icon"></span> Metal
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "CHILDPROFF" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("CHILDPROFF"))"
                                                @onclick='() => SetFormaCap("CHILDPROFF")'>
                                            <span class="radio-icon"></span> Childproff
                                        </button>
                                    </div> *@
                                    <!-- FORMAS DE TAPA - DINÁMICO -->
                                    <div class="segmented">
                                        @foreach (var forma in GetAvailableCapShapes())
                                        {
                                            <button type="button"
                                                    class="segmented-item @(IsCapShapeSelected(forma.Key) ? "active" : "")"
                                                    @onclick="() => OnCapShapeChange(forma.Key)"
                                                    disabled="@IsSaving">
                                                <span class="radio-icon"></span>
                                                @forma.Value
                                            </button>
                                        }
                                    </div>
                                </div>

                                <!-- Diámetro tapa (sincronizado) -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.DiameterThread"]</label>
                                    <InputSelect class="form-select" TValue="string" @bind-Value="CapConfig.Diametro" disabled>
                                        <option value="">@Localization["modalContainer.Selectadiameter"]</option>
                                        @if (!string.IsNullOrEmpty(CapConfig.Diametro))
                                        {
                                            <option value="@CapConfig.Diametro">@CapConfig.Diametro</option>
                                        }
                                    </InputSelect>
                                    <small class="hint">Sincronizado con el bote</small>
                                </div>

                                <!-- Color tapa -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Color"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="CapConfig.Color"
                                                 @bind-Value:after="OnCapColorChangedAsync">
                                        <option value="">@Localization["modalContainer.Selectacolor"]</option>
                                        @foreach (var c in OptionsColorCoverFiltered)
                                        {
                                            <option value="@(c.Label ?? c.Value)">@(c.Label ?? c.Value)</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Sleeve -->
                                <div class="field">
                                    <label class="checkbox">
                                          <input type="checkbox" @bind="CapConfig.Sleeve" @bind:after="OnSleeveChanged" />
      
                                        <span>Sleever</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    }
                </div>

                <!-- Footer -->
                <div class="modal-footer">
                    <button type="button" class="btn-cancel" @onclick="HideModal" disabled="@IsSaving">
                        @Localization["NavBar.Cancel"]
                    </button>
                    <button type="button"
                            class="btn-primary"
                            @onclick="SaveAsync"
                            disabled="@IsSaving" 
                            style="min-width: 100px;">
                        @if (IsSaving)
                        {
                            <span class="spinner-save"></span>
                            <span>Guardando...</span>
                        }
                        else
                        {
                            @Localization["NavBar.Save"]
                        }
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    // ===== Props =====
    [Parameter] public bool IsVisible { get; set; } = false;
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnSave { get; set; }
    [Parameter] public EventCallback<(BoteDataItem Bote, CapDataItem Cap)> OnSaveData { get; set; }
    [Parameter] public EventCallback<UpdatedOptions> OnOptionsUpdated { get; set; }
    // Props de datos
    [Parameter] public string CodeRG35 { get; set; } = string.Empty;
    [Parameter] public string PesoTotal { get; set; } = string.Empty;
    [Parameter] public BoteDataItem? SelectedOption { get; set; }
    [Parameter] public CapDataItem? SelectedOptionCap { get; set; }
    [Parameter] public JsonElement RelacionBote { get; set; }
    [Parameter] public JsonElement RelacionTapa { get; set; }
    [Parameter] public IEnumerable<CapDataItem>? CapData { get; set; }
    [Parameter] public IEnumerable<BoteDataItem>? BoteData { get; set; }
    [Parameter] public IEnumerable<ColorOption>? OptionsColorBote { get; set; }
    [Parameter] public IEnumerable<ColorOption>? OptionsColorCover { get; set; }
    [Parameter] public IEnumerable<string>? Capacidades { get; set; }
    [Parameter] public Dictionary<string, List<string>>? CapacidadToDiametros { get; set; }
    [Parameter] public IEnumerable<string>? Materiales { get; set; }
    [Parameter] public string Characteristics { get; set; } = string.Empty;
    private bool IsSaving { get; set; } = false;
   
    [Parameter] public EventCallback<bool> SetAccordionOpen { get; set; }
    private readonly Dictionary<string, Dictionary<string, (double Diameter, double Height)>> CapDimensionsMap = new()
    {
        ["SIMPLE"] = new()
        {
            ["D38"] = (40.2, 11.7),
            ["D45"] = (47.37, 11.7),
            ["D53"] = (55.0, 12.0),
            ["D63"] = (65.0, 12.5),
            ["D70"] = (72.0, 13.0)
        },
        ["METAL"] = new()
        {
            ["D38"] = (41.0, 12.5),
            ["D45"] = (48.0, 12.5),
            ["D53"] = (56.0, 13.0),
            ["D63"] = (66.0, 13.5),
            ["D70"] = (73.0, 14.0)
        },
        ["CHILDPROOF"] = new()
        {
            ["D38"] = (45.21, 17.3),
            ["D45"] = (51.99, 17.306),
            ["D53"] = (60.0, 18.0),
            ["D63"] = (70.0, 18.5),
            ["D70"] = (77.0, 19.0)
        }
    };

    private readonly Dictionary<string, Dictionary<string, BoteDimension>> DimensionsMap = new()
    {
        ["150"] = new()
        {
            ["D45"] = new(88.3, 55.3, 43.82),
            ["D38"] = new(85.0, 52.0, 38.0)
        },
        ["200"] = new()
        {
            ["D45"] = new(105.86, 60.0, 43.82),
            ["D38"] = new(102.0, 57.0, 38.0),
            ["D53"] = new(98.0, 62.0, 53.0),
            ["D70"] = new(95.0, 65.0, 70.0)
        },
        ["250"] = new()
        {
            ["D45"] = new(111.3, 63.91, 43.82),
            ["D38"] = new(108.0, 60.0, 38.0)
        },
        ["300"] = new()
        {
            ["D45"] = new(118.95, 68.99, 43.82),
            ["D63"] = new(115.0, 72.0, 63.0)
        },
        ["400"] = new()
        {
            ["D45"] = new(130.87, 72.69, 43.82),
            ["D63"] = new(127.0, 75.0, 63.0)
        },
        ["500"] = new()
        {
            ["D45"] = new(155.0, 80.0, 43.82),
            ["D63"] = new(150.0, 83.0, 63.0)
        }
    };
    private const string NO_IMAGE_AVAILABLE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAZJSURBVHgB7d3dcdswEAXQq5n8ZzpIB04F6sCpIKkgqSCpIK4gqSCpIK4gqSCuIKkgqSCuIKkAb8gZjmyJokiCBPB9Z3Y8tmRLFnkFLBYLAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgP9qrV+I6JZMaa2/6vW1GcHx1BqVUrb+3imlvpERB1FKfSWib0S0YGTMQdy/Nm6JaMJo3M6rICJaSI9qIYRer/MEQRAROLg2C0bhIPa7JAiiiQhCRJTG4yDqICJkiWAwj4OoY4gQIggGc0HMgwiCwVwQU99LEGsIRoMsVrvJWgg/hHa/CTBKj0HESZCjE2S6EVqeJAgSBINJG0Rc8N5aGLRBYIDkQayfQizJ0H+FEeJGTRxEhWz9HcL2QZIg0eDOPYkMJYKgD2mzWF5JzWIBQhMnQYhonRGx7oFBxEmQKRG9MBqWOEFm+3pZDOMb4mGy78HrNEb4VnrxSJgY/z7bz5SINp1eKyUgCCJOcIa0DKLGy10WqyJOqZIEQXDoJvdqMBW2kxCc7L8rlOXa4GAqPGchwhJc2Rf2E4k5C5xzEJm6J4gQCOcgKtGQPCJBJHJJECkQISLgQIJIgQiBcFmsjjhsOHQQ9b2VfiDzUm6HJCqGCCGdK0VIY+AgCpLOlRJBMJSLINYQPLRGEHziLIJYQ/DQGkH6xkH8OM6H1gjSN9c7rrDnQDlIQSUhQhCZmCcIEQQpOJkfwyRI31CEcgezBCEiQg7rK84FCnc6OYYQQfAx5utjCBGkb3qkO5e2xrx8CSFI1zhIdz7nCyuWiOYIglN8XD8vhTCJHT/YGNJbCJH8rHHNgqiQDv+tNYKkRBOxlUJknUJE8f0XIkg2WooM3USWo+hziSg/mEKkRObiAKn7Zy9ER0sRQiQBU2h0FQStOSFEJrEFQbIg8RQiHYQgHJiqECKQo8iMCCE6MoUIlCiykDJACBGAKUQa0IYUor0qhOiAKUTg48F8aFdCiIUeHswIIZwwhOgA6JEOJqJ1w6wdgjQPtI4IIejGnz0aSr/YROVAq9Zaa/0kfQnIiZA/tD5DwmeSMhRE5D8OoqRJEPJMlvRPKUQgEz1AHEQJkyAi8nqOxfxMSULJhvRnCQeRnO1rlrDPGGOiOEhfJJxzqPYaJxICqRAiEBRBkpAggiBFIKNBCCJVCvFsEkGkSiFYFQdRJYJglCwBQaRINfGG7rWJQkkikH9BCiJJAsUIIilJ+kMQqRTpBxYOokqCYJQ0QRAkzsSJBAjiT6LMJ4KI5aJULgQVxJ9gQ/dwJKgcMdAgCkGk2uT+G34uy75AEJ9pJG1f7C9B1eEFhJEyGkbfRu7hvZQOCCe1cBAVQvQM8V6GhtXvpUg8dwiCCAJvmE7O9Yo8CDJy4YdwXJQCEG2klD5cKAkiGOoYfQ6XxUIJgRBSBe+zWAEQQiT8F6u7bLg1bZITciRxBLnhfm0m4C9JBHkoyfX4y5VH+LIRxB8zzLIcXKuFQBC/XBZL9iCCuJOKLLKH13lcUoZzTi5BCYJhShKkO0PxBdOVJQS3yATJg4iBJIFJgsAVQiDw+kBJFusUlCQsE8qI+HQMIYJIMjNIdOgddHhZ3JdEQAiJgjUfSj5JJg9bFyoYxCZUILlGBJECIQJJiMG+TsBuRGQT9mGRMAQRQsgQRMJwQdSQIXxNMgN/3GIIhBwOhBbcbLi/OiSIb3K0Q6/iN/v3JkNJQLzheJ/o1cOt9M1I/xnvT5nCUP7JfGiOEP05cxgtQwD3Q3PfPRqYDOUQRLLEpMkQMmQeJfqH6bH3BPrz5kCn+8BTGMYYX4h8GJhz8DhBVKJJIYSQo/CY8qWUekdEFx1f7ksS82+l1Ju0lQsCCRHJSqk8nLz8S0TvZOydj4gQ+XcGiQjKh3R3h5FiTLFxnb3xEJE7ifVWWxCVGvtIhzGvlmrJy/csiDOxk3aZOmGrpe5IHc+CyKJhzq2YJvJBQ21RHQkQxJkkCUJEUmcII8nJbJTsWQJBCiCMPPHPWvUWRBV2V9ZwJzGBSG2DYS7+B0P8V5WKLZ3fAAAAAElFTkSuQmCC";

    private void UpdateCurrentDimensions()
    {
        Console.WriteLine($"UpdateCurrentDimensions - Capacidad: {BoteConfig.Capacidad}, Diametro: {BoteConfig.Diametro}");

        if (!string.IsNullOrEmpty(BoteConfig.Capacidad) && !string.IsNullOrEmpty(BoteConfig.Diametro))
        {
            if (DimensionsMap.TryGetValue(BoteConfig.Capacidad, out var capacidadDims))
            {
                if (capacidadDims.TryGetValue(BoteConfig.Diametro, out var dimension))
                {
                    CurrentBoteDimension = dimension;
                    Console.WriteLine($"Dimensiones encontradas - Altura: {dimension.Altura}, Base: {dimension.DiametroBase}, Boca: {dimension.DiametroBoca}");
                    return;
                }
            }
        }

        // Valores por defecto si no se encuentra la combinación
        CurrentBoteDimension = null;
        Console.WriteLine("Usando dimensiones por defecto");
    }
    private BoteDimension? CurrentBoteDimension { get; set; }
    private void UpdateCapDimensions()
    {
        if (!string.IsNullOrEmpty(CapConfig.Forma) && !string.IsNullOrEmpty(CapConfig.Diametro))
        {
            var formaUpper = NormFormaCap(CapConfig.Forma);

            if (CapDimensionsMap.TryGetValue(formaUpper, out var diametros))
            {
                if (diametros.TryGetValue(CapConfig.Diametro, out var dimension))
                {
                    CurrentCapDimension = dimension;
                    return;
                }
            }
        }

        // Valores por defecto si no se encuentra la combinación
        CurrentCapDimension = null;
    }
    private (double Diameter, double Height)? CurrentCapDimension { get; set; }
    [Inject] private IApiService ApiService { get; set; } = default!;
    [Inject] private ILocalizationService Localization { get; set; } = default!;
    public sealed class UpdatedOptions
    {
        public SelectedBoteOption? BoteOption { get; set; }
        public SelectedCapOption? CapOption { get; set; }
        public string Characteristics { get; set; } = "";
    }
    public sealed class SelectedCapOption
    {
        public string? CapTapa { get; set; }
        public string? CapBoca { get; set; }
        public string? CapColor { get; set; }
        public bool CapSleever { get; set; }
    }
    public sealed class SelectedBoteOption
    {
        public string? BoteForma { get; set; }
        public string? BoteCapacidad { get; set; }
        public string? BoteBoca { get; set; }
        public string? BoteColor { get; set; }
        public string? BoteMaterial { get; set; }
    }
    // Props opcionales (fallbacks externos)
    private string SelectedBottleShape { get; set; } = "";
    private string SelectedCapShape { get; set; } = "";
    // Formas habilitadas según los filtros actuales
    private HashSet<string> AvailableBottleForms = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> AvailableCapForms = new(StringComparer.OrdinalIgnoreCase);
    private string ComponentId { get; set; } = Guid.NewGuid().ToString("N");
    private ElementReference bottleWrapper;
    // ===== Estado =====
    private bool IsBottleTab { get; set; } = true;
    private BoteConfigModel BoteConfig { get; set; } = new() { ImagenBote = NO_IMAGE_AVAILABLE };
    private CapConfigModel CapConfig { get; set; } = new() { ImagenCap = NO_IMAGE_AVAILABLE };

    // Fallbacks UI por defecto (si no llegan datos/colores)
    private List<string> CapacidadOptionsUI { get; set; } = new();
    private Dictionary<string, List<string>> CapacidadToDiametrosUI { get; set; } = new();

    private List<string> DiametroOptionsUI { get; set; } = new();
    private List<string> MaterialOptionsUI { get; set; } = new() ;

    private List<ColorOption> OptionsColorBoteUI { get; set; } = new()
    {
        new("Clear", "#CCCCCC"), new("Amber", "#FFBF00"), new("Black", "#000000"), new("White","#FFFFFF")
    };
    private List<ColorOption> OptionsColorCoverUI { get; set; } = new()
    {
        new("White", "#FFFFFF"), new("Black", "#000000"), new("Blue", "#0D6EFD")
    };

    // ====================== NORMALIZACIONES ======================
    private static string N(string? s) => (s ?? "").Trim();
    private static string NUp(string? s) => N(s).ToUpperInvariant();

    private static string NormFormaBote(string? f)
    {
        f = NUp(f);
        return f switch
        {
            "REDONDO" => "ROUND",
            "CUADRADO" => "SQUARE",
            "CILINDRICO" or "CILÍNDRICO" or "CYL" => "CYLINDRICAL",
            "" => "ROUND",
            _ => f
        };
    }
    private static string NormFormaCap(string? f)
    {
        f = NUp(f);
        return f switch
        {
            "BASIC" => "SIMPLE",
            "METÁLICA" or "METALICA" => "METAL",
            "CHILDPROOF" or "NIÑOS" or "NINOS" => "CHILDPROOF",
            "" => "SIMPLE",
            _ => f
        };
    }
    private static string NormDiam(string? d) => NUp(d);

    // ====================== LISTAS FILTRADAS PARA LOS SELECT ======================
    private List<string> CapacidadOptionsFiltered = new();
    private List<string> DiametroOptionsFiltered = new();
    private List<string> MaterialOptionsFiltered = new();
    private List<ColorOption> OptionsColorBoteFiltered = new();
    private List<ColorOption> OptionsColorCoverFiltered = new();
    // ===== MÉTODOS NUEVOS PARA OBTENER LAS IMÁGENES =====
    // Agregar estos métodos en la sección de código del componente:
    private void UpdateBoteImage()
    {
        if (BoteData == null || !BoteData.Any())
        {
            BoteConfig.ImagenBote = NO_IMAGE_AVAILABLE;
            return;
        }

        var availableBotes = BoteData.AsEnumerable();
        if (!string.IsNullOrEmpty(PesoTotal) && decimal.TryParse(PesoTotal, out decimal pesoTotalDecimal))
        {
            availableBotes = availableBotes.Where(b => b.PesoMaximo >= pesoTotalDecimal);
        }

        var matchingBote = availableBotes.FirstOrDefault(b =>
            (string.IsNullOrEmpty(BoteConfig.Forma) ||
             string.Equals(NormFormaBote(b.Forma), NormFormaBote(BoteConfig.Forma), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Capacidad) ||
             string.Equals(b.Capacidad, BoteConfig.Capacidad, StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Diametro) ||
             string.Equals(NormDiam(b.Diametro), NormDiam(BoteConfig.Diametro), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Material) ||
             string.Equals(b.Material, BoteConfig.Material, StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Color) ||
             string.Equals(b.Color, BoteConfig.Color, StringComparison.OrdinalIgnoreCase))
        );

        if (matchingBote != null)
        {
            // ⚡ Cargar imagen bajo demanda
            BoteConfig.ImagenBote = GetBoteImageLazy(matchingBote) ?? NO_IMAGE_AVAILABLE;
        }
        else
        {
            BoteConfig.ImagenBote = NO_IMAGE_AVAILABLE;
        }
    }
 
    private BoteDataItem? FindBestPartialMatchBote()
    {
        if (BoteData == null || !BoteData.Any())
            return null;

        // Prioridad de coincidencia: Forma > Capacidad > Diámetro > Material > Color
        // Intentar encontrar la mejor coincidencia posible
        // NUEVO: Filtrar por peso si existe PesoTotal
        var availableBotes = BoteData.AsEnumerable();
        if (!string.IsNullOrEmpty(PesoTotal) && decimal.TryParse(PesoTotal, out decimal pesoTotalDecimal))
        {
            availableBotes = availableBotes.Where(b => b.PesoMaximo >= pesoTotalDecimal);
            if (!availableBotes.Any())
            {
                Console.WriteLine($"No hay botes que soporten el peso de {pesoTotalDecimal}");
                return null;
            }
        }

        // Primero intentar con forma, capacidad y diámetro
        var match = BoteData.FirstOrDefault(b =>
            !string.IsNullOrWhiteSpace(b.ImagenBote) &&
            (string.IsNullOrEmpty(BoteConfig.Forma) || 
             string.Equals(NormFormaBote(b.Forma), NormFormaBote(BoteConfig.Forma), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Capacidad) || 
             string.Equals(b.Capacidad, BoteConfig.Capacidad, StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Diametro) || 
             string.Equals(NormDiam(b.Diametro), NormDiam(BoteConfig.Diametro), StringComparison.OrdinalIgnoreCase))
        );

        if (match != null) return match;

        // Si no hay coincidencia, intentar solo con forma y capacidad
        match = BoteData.FirstOrDefault(b =>
            !string.IsNullOrWhiteSpace(b.ImagenBote) &&
            (string.IsNullOrEmpty(BoteConfig.Forma) || 
             string.Equals(NormFormaBote(b.Forma), NormFormaBote(BoteConfig.Forma), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(BoteConfig.Capacidad) || 
             string.Equals(b.Capacidad, BoteConfig.Capacidad, StringComparison.OrdinalIgnoreCase))
        );

        if (match != null) return match;

        // Si aún no hay coincidencia, intentar solo con forma
        match = BoteData.FirstOrDefault(b =>
            !string.IsNullOrWhiteSpace(b.ImagenBote) &&
            !string.IsNullOrEmpty(BoteConfig.Forma) &&
            string.Equals(NormFormaBote(b.Forma), NormFormaBote(BoteConfig.Forma), StringComparison.OrdinalIgnoreCase)
        );

        if (match != null) return match;

        // Como último recurso, devolver cualquier imagen disponible
        return BoteData.FirstOrDefault(b => !string.IsNullOrWhiteSpace(b.ImagenBote));
    }

    private async Task OnImageLoaded()
    {
        if (IsBottleTab)
        {
            await Task.Delay(50); // Pequeño delay para asegurar el renderizado
            await AdjustDimensionLines();
        }
    }
    private async Task UpdateBodyScroll()
    {
        await JSRuntime.InvokeVoidAsync("eval", $@"
        if ({IsVisible.ToString().ToLower()}) {{
            document.body.style.overflow = 'hidden';
            document.body.classList.add('modal-open');
        }} else {{
            document.body.style.overflow = '';
            document.body.classList.remove('modal-open');
        }}
    ");
    }
    private async Task OnSleeveChanged()
    {
        UpdateCapImage(); // Actualizar imagen cuando cambie el sleeve
        await InvokeAsync(StateHasChanged);
    }
    private async Task OnCapImageLoaded()
    {
        await Task.Delay(100); // Pequeño delay para asegurar el renderizado
        if (!IsBottleTab) // Solo si estamos en la pestaña de tapa
        {
            await AdjustCapDimensionLines();
        }
    }
    private void UpdateCapImage()
    {
        Console.WriteLine($"UpdateCapImage - Forma: {CapConfig.Forma}, Diametro: {CapConfig.Diametro}, Color: {CapConfig.Color}, Sleeve: {CapConfig.Sleeve}");

        if (CapData == null || !CapData.Any())
        {
            Console.WriteLine("No hay datos de CapData");
            CapConfig.ImagenCap = NO_IMAGE_AVAILABLE;
            return;
        }

        Console.WriteLine($"Total de registros en CapData: {CapData.Count()}");

        var matchingCap = CapData.FirstOrDefault(c =>
            (string.IsNullOrEmpty(CapConfig.Forma) ||
             string.Equals(NormFormaCap(c.Forma), NormFormaCap(CapConfig.Forma), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(CapConfig.Diametro) ||
             string.Equals(NormDiam(c.Diametro), NormDiam(CapConfig.Diametro), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(CapConfig.Color) ||
             string.Equals(c.Color, CapConfig.Color, StringComparison.OrdinalIgnoreCase)) &&
            (c.Sleeve == CapConfig.Sleeve)
        );

        if (matchingCap != null)
        {
            Console.WriteLine("Coincidencia exacta encontrada " +DateTime.Now.ToString());
            // ⚡ Cargar imagen bajo demanda
            CapConfig.ImagenCap = GetCapImageLazy(matchingCap) ?? NO_IMAGE_AVAILABLE;
        }
        else
        {
            Console.WriteLine("No se encontró ninguna imagen");
            CapConfig.ImagenCap = NO_IMAGE_AVAILABLE;
        }

        Console.WriteLine($"Imagen final de tapa: {CapConfig.ImagenCap?.Substring(0, Math.Min(50, CapConfig.ImagenCap.Length))}...");
    }
    private CapDataItem? FindBestPartialMatchCap()
    {
        if (CapData == null || !CapData.Any())
            return null;

        // Prioridad de coincidencia: Forma > Diámetro > Color

        // Primero intentar con forma y diámetro
        var match = CapData.FirstOrDefault(c =>
            !string.IsNullOrWhiteSpace(c.ImagenCap) &&
            (string.IsNullOrEmpty(CapConfig.Forma) || 
             string.Equals(NormFormaCap(c.Forma), NormFormaCap(CapConfig.Forma), StringComparison.OrdinalIgnoreCase)) &&
            (string.IsNullOrEmpty(CapConfig.Diametro) || 
             string.Equals(NormDiam(c.Diametro), NormDiam(CapConfig.Diametro), StringComparison.OrdinalIgnoreCase))
        );

        if (match != null) return match;

        // Si no hay coincidencia, intentar solo con forma
        match = CapData.FirstOrDefault(c =>
            !string.IsNullOrWhiteSpace(c.ImagenCap) &&
            !string.IsNullOrEmpty(CapConfig.Forma) &&
            string.Equals(NormFormaCap(c.Forma), NormFormaCap(CapConfig.Forma), StringComparison.OrdinalIgnoreCase)
        );

        if (match != null) return match;

        // Si no hay coincidencia, intentar solo con diámetro
        match = CapData.FirstOrDefault(c =>
            !string.IsNullOrWhiteSpace(c.ImagenCap) &&
            !string.IsNullOrEmpty(CapConfig.Diametro) &&
            string.Equals(NormDiam(c.Diametro), NormDiam(CapConfig.Diametro), StringComparison.OrdinalIgnoreCase)
        );

        if (match != null) return match;

        // Como último recurso, devolver cualquier imagen disponible
        return CapData.FirstOrDefault(c => !string.IsNullOrWhiteSpace(c.ImagenCap));
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsVisible)
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 300);
            });
        ");
        }
        await base.OnAfterRenderAsync(firstRender);


    }
    private async Task SwitchToBottleTab()
    {
        IsBottleTab = true;
        UpdateBoteImage(); // Asegurar actualización
        await ForceAdjustDimensions();
    }

    private async Task SwitchToCapTab()
    {
        IsBottleTab = false;
        UpdateCapImage(); // Asegurar actualización
        await ForceAdjustDimensions();
    }
    public string GetCapDiameterText()
    {
        // Si no hay dimensiones cargadas, intentar cargarlas
        if (CurrentCapDimension == null &&
            !string.IsNullOrEmpty(CapConfig.Forma) &&
            !string.IsNullOrEmpty(CapConfig.Diametro))
        {
            UpdateCapDimensions();
        }

        // Si hay dimensiones válidas, mostrarlas; si no, mostrar N/A
        return CurrentCapDimension.HasValue
            ? $"{CurrentCapDimension.Value.Diameter:F2} mm"
            : "N/A";
    }
    public string GetCapHeightText()
    {
        // Si no hay dimensiones cargadas, intentar cargarlas
        if (CurrentCapDimension == null &&
            !string.IsNullOrEmpty(CapConfig.Forma) &&
            !string.IsNullOrEmpty(CapConfig.Diametro))
        {
            UpdateCapDimensions();
        }

        // Si hay dimensiones válidas, mostrarlas; si no, mostrar N/A
        return CurrentCapDimension.HasValue
            ? $"{CurrentCapDimension.Value.Height:F2} mm"
            : "N/A";
    }
    private bool HasBoteDimensions()
    {
        return CurrentBoteDimension != null;
    }

    private bool HasCapDimensions()
    {
        return CurrentCapDimension.HasValue;
    }
    private string GetDimensionAvailabilityMessage()
    {
        if (!HasBoteDimensions() && !string.IsNullOrEmpty(BoteConfig.Capacidad) && !string.IsNullOrEmpty(BoteConfig.Diametro))
        {
            return $"Las dimensiones para {BoteConfig.Capacidad}cc con diámetro {BoteConfig.Diametro} no están disponibles.";
        }
        return string.Empty;
    }

    private string GetCapDimensionAvailabilityMessage()
    {
        if (!HasCapDimensions() && !string.IsNullOrEmpty(CapConfig.Forma) && !string.IsNullOrEmpty(CapConfig.Diametro))
        {
            return $"Las dimensiones para tapa {CapConfig.Forma} con diámetro {CapConfig.Diametro} no están disponibles.";
        }
        return string.Empty;
    }
    private async Task OnBottleConfigChanged()
    {
        RecomputeAllFilters();
        UpdateBoteImage();
        await InvokeAsync(StateHasChanged);

        // Esperar un momento para que el DOM se actualice
        await Task.Delay(100);
        await AdjustDimensionLines();
    }
    // ===== REEMPLAZAR EL MÉTODO AdjustDimensionLines =====
    // ===== 1. CORREGIR EL MÉTODO AdjustDimensionLines PARA POSICIONAR CORRECTAMENTE LA LÍNEA =====

 private async Task AdjustDimensionLines()
    {
        try
        {
            var script = $@"
        (function() {{
            const container = document.getElementById('bottle-container-{ComponentId}');
            if (!container) {{
                console.log('Container no encontrado');
                return;
            }}

            const img = container.querySelector('img');
            if (!img) {{
                console.log('Imagen no encontrada');
                return;
            }}

            function adjustDimensions() {{
                const imgRect = img.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const wrapperElement = document.querySelector('.bottle-visual-wrapper[data-size]');
                const wrapperRect = wrapperElement ? wrapperElement.getBoundingClientRect() : containerRect;

                const imgTop = imgRect.top - wrapperRect.top;
                const imgLeft = imgRect.left - wrapperRect.left;
                const imgWidth = imgRect.width;
                const imgHeight = imgRect.height;

                // LÍNEA SUPERIOR (Diámetro de boca) - sobre el cuello
                const dimTop = document.querySelector('#dimension-lines-{ComponentId} .dimension-top');
                if (dimTop) {{
                    const neckWidth = imgWidth * 0.40;
                    const topPosition = imgTop - 35;
                    
                    dimTop.style.top = topPosition + 'px';
                    dimTop.style.width = neckWidth + 'px';
                    dimTop.style.left = '50%';
                    dimTop.style.transform = 'translateX(-50%)';
                }}

                // LÍNEA IZQUIERDA (Altura del cuerpo)
                const dimLeft = document.getElementById('dim-left-{ComponentId}');
                if (dimLeft) {{
                    const neckHeight = imgHeight * 0.15;
                    const baseHeight = imgHeight * 0.05;
                    const bodyHeight = imgHeight - neckHeight - baseHeight;
                    const leftPosition = imgLeft - 65; // Más separación
                    const topPosition = imgTop + neckHeight;
                    
                    dimLeft.style.left = leftPosition + 'px';
                    dimLeft.style.top = topPosition + 'px';
                    dimLeft.style.height = bodyHeight + 'px';
                }}

                // LÍNEA INFERIOR (Diámetro de base)
                const dimBottom = document.querySelector('#dimension-lines-{ComponentId} .dimension-bottom');
                if (dimBottom) {{
                    const baseWidth = imgWidth * 0.75;
                    const bottomPosition = (wrapperRect.height - imgRect.bottom + wrapperRect.top) - 20;
                    
                    dimBottom.style.bottom = bottomPosition + 'px';
                    dimBottom.style.width = baseWidth + 'px';
                    dimBottom.style.left = '50%';
                    dimBottom.style.transform = 'translateX(-50%)';
                }}
            }}

            if (!img.complete) {{
                img.onload = adjustDimensions;
            }} else {{
                adjustDimensions();
            }}

            let resizeTimeout;
            window.addEventListener('resize', function() {{
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(adjustDimensions, 150);
            }});
        }})();
        ";

            await JSRuntime.InvokeVoidAsync("eval", script);
        }
        catch (Exception ex)
        {
            Logger?.LogWarning("Error adjusting dimension lines: {Message}", ex.Message);
        }
    }
    private async Task AdjustDimensionLinesAlternative()
    {
        var jsCode = @"
        window.adjustBottleDimensions = function(componentId) {
            const container = document.getElementById('bottle-container-' + componentId);
            if (!container) return;

            const svg = container.querySelector('svg');
            if (!svg) return;

            // Obtener el viewBox del SVG para determinar las proporciones
            const viewBox = svg.getAttribute('viewBox');
            const rect = svg.getBoundingClientRect();

            // Calcular posiciones basadas en el tamaño real
            const dimLeft = document.getElementById('dim-left-' + componentId);
            if (dimLeft) {
                // Ajustar altura de la línea vertical al 85% de la altura del SVG
                const lineHeight = rect.height * 0.85;
                const lineTop = (rect.height * 0.075); // Comenzar al 7.5% desde arriba

                dimLeft.style.height = lineHeight + 'px';
                dimLeft.style.top = (75 + lineTop) + 'px';
            }
        };
    ";

        // Primero, registrar la función si no existe
        await JSRuntime.InvokeVoidAsync("eval", jsCode);

        // Luego, llamar la función
        await JSRuntime.InvokeVoidAsync("adjustBottleDimensions", ComponentId);
    }



    // ====================== RECOMPUTES (CASCADA) ======================
    private void RecomputeBottleFilters()
    {
        var all = (BoteData ?? Enumerable.Empty<BoteDataItem>()).ToList();
        Console.WriteLine($"=== INICIO RecomputeBottleFilters ===");
        Console.WriteLine($"Total botes: {all.Count}");

        // FILTRO DE PESO
        if (!string.IsNullOrEmpty(PesoTotal) && decimal.TryParse(PesoTotal, out decimal pesoTotalDecimal))
        {
            all = all.Where(b => b.PesoMaximo >= pesoTotalDecimal).ToList();
            Console.WriteLine($"Después de peso: {all.Count}");
        }

        string forma = NormFormaBote(BoteConfig.Forma);
        string capSel = N(BoteConfig.Capacidad);
        string diaSel = NormDiam(BoteConfig.Diametro);
        string matSel = N(BoteConfig.Material);
        string colorSel = N(BoteConfig.Color);

        Console.WriteLine($"Color seleccionado: '{colorSel}'");

        // ===== FORMAS DISPONIBLES =====
        AvailableBottleForms = new HashSet<string>(
            all.Where(b =>
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel) &&
                (string.IsNullOrEmpty(colorSel) || N(b.Color) == colorSel))
               .Select(b => NormFormaBote(b.Forma))
               .Distinct(StringComparer.OrdinalIgnoreCase),
            StringComparer.OrdinalIgnoreCase
        );

        if (!string.IsNullOrEmpty(forma) && !AvailableBottleForms.Contains(forma))
            BoteConfig.Forma = forma = "";

        // ===== CAPACIDADES =====
        CapacidadOptionsFiltered = all
            .Where(b =>
                (string.IsNullOrEmpty(forma) || NormFormaBote(b.Forma) == forma) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel) &&
                (string.IsNullOrEmpty(colorSel) || N(b.Color) == colorSel))
            .Select(b => N(b.Capacidad))
            .Where(s => !string.IsNullOrEmpty(s))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => int.TryParse(c, out var n) ? n : int.MaxValue)
            .ToList();

        Console.WriteLine($"Capacidades: {string.Join(", ", CapacidadOptionsFiltered)}");

        if (!string.IsNullOrEmpty(capSel) && !CapacidadOptionsFiltered.Contains(capSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Capacidad = capSel = "";

        // ===== DIÁMETROS =====
        DiametroOptionsFiltered = all
            .Where(b =>
                (string.IsNullOrEmpty(forma) || NormFormaBote(b.Forma) == forma) &&
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel) &&
                (string.IsNullOrEmpty(colorSel) || N(b.Color) == colorSel))
            .Select(b => NormDiam(b.Diametro))
            .Where(s => !string.IsNullOrEmpty(s))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(d => d)
            .ToList();

        Console.WriteLine($"Diámetros filtrados: {string.Join(", ", DiametroOptionsFiltered)}");

        if (!string.IsNullOrEmpty(diaSel) && !DiametroOptionsFiltered.Contains(diaSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Diametro = diaSel = "";

        // ===== MATERIALES =====
        MaterialOptionsFiltered = all
            .Where(b =>
                (string.IsNullOrEmpty(forma) || NormFormaBote(b.Forma) == forma) &&
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(colorSel) || N(b.Color) == colorSel))
            .Select(b => N(b.Material))
            .Where(s => !string.IsNullOrEmpty(s))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(m => m)
            .ToList();

        Console.WriteLine($"Materiales: {string.Join(", ", MaterialOptionsFiltered)}");

        if (!string.IsNullOrEmpty(matSel) && !MaterialOptionsFiltered.Contains(matSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Material = matSel = "";

        // ===== COLORES =====
        var colorNames = all
            .Where(b =>
                (string.IsNullOrEmpty(forma) || NormFormaBote(b.Forma) == forma) &&
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel))
            .Select(b => N(b.Color))
            .Where(s => !string.IsNullOrEmpty(s))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => c)
            .ToList();

        OptionsColorBoteFiltered = colorNames.Any()
            ? MapNamesToColorOptions(colorNames, OptionsColorBote ?? OptionsColorBoteUI)
            : (OptionsColorBote?.ToList() ?? OptionsColorBoteUI.ToList());

        if (!string.IsNullOrEmpty(colorSel) &&
            !OptionsColorBoteFiltered.Any(o => string.Equals((o.Label ?? o.Value), colorSel, StringComparison.OrdinalIgnoreCase)))
        {
            BoteConfig.Color = "";
        }

        // SINCRONIZAR TAPA
        var previousCapDiameter = CapConfig.Diametro;
        CapConfig.Diametro = string.IsNullOrEmpty(BoteConfig.Diametro) ? "" : BoteConfig.Diametro;

        if (previousCapDiameter != CapConfig.Diametro)
            UpdateCapImage();

        UpdateCapImage();
        UpdateBoteImage();
        UpdateCurrentDimensions();
        Console.WriteLine($"=== FIN ===");
    }
    private Dictionary<string, string> GetAvailableBottleShapes()
    {
        var shapes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        // Obtener filtros activos (excluyendo forma)
        string capSel = N(BoteConfig.Capacidad);
        string diaSel = NormDiam(BoteConfig.Diametro);
        string matSel = N(BoteConfig.Material);
        string colorSel = N(BoteConfig.Color);

        // Aplicar filtro de peso
        var all = (BoteData ?? Enumerable.Empty<BoteDataItem>()).ToList();
        if (!string.IsNullOrEmpty(PesoTotal) && decimal.TryParse(PesoTotal, out decimal pesoTotalDecimal))
        {
            all = all.Where(b => b.PesoMaximo >= pesoTotalDecimal).ToList();
        }

        // Obtener formas disponibles según los filtros activos
        var availableShapes = all
            .Where(b =>
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel) &&
                (string.IsNullOrEmpty(colorSel) || N(b.Color) == colorSel))
            .Select(b => b.Forma.ToUpperInvariant())
            .Distinct()
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        Console.WriteLine($"GetAvailableBottleShapes - Formas disponibles: {string.Join(", ", availableShapes)}");

        // Mapeo de formas con sus etiquetas
        var shapeLabels = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["ROUND"] = "Round",
            ["SQUARE"] = "Square",
            ["CYLINDRICAL"] = "Cylindrical"
        };

        // Solo agregar las formas que existen con los filtros actuales
        foreach (var kvp in shapeLabels)
        {
            if (availableShapes.Contains(kvp.Key))
            {
                shapes[kvp.Key] = kvp.Value;
            }
        }

        return shapes;
    }
    private Dictionary<string, string> GetAvailableCapShapes()
    {
        var shapes = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        // Obtener filtros activos (excluyendo forma de tapa)
        var diaSel = NormDiam(BoteConfig.Diametro);
        string colorCapSel = N(CapConfig.Color);

        // Filtrar tapas por diámetro sincronizado con el bote
        var availableShapes = (CapData ?? Enumerable.Empty<CapDataItem>())
            .Where(c =>
                (string.IsNullOrEmpty(diaSel) || NormDiam(c.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(colorCapSel) || N(c.Color) == colorCapSel))
            .Select(c => c.Forma.ToUpperInvariant())
            .Distinct()
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        Console.WriteLine($"GetAvailableCapShapes - Formas disponibles: {string.Join(", ", availableShapes)}");

        // Mapeo de formas con sus etiquetas
        var shapeLabels = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            ["SIMPLE"] = "Simple",
            ["METAL"] = "Metal",
            ["CHILDPROOF"] = "Childproof"
        };

        // Solo agregar las formas que cumplen los filtros
        foreach (var kvp in shapeLabels)
        {
            if (availableShapes.Contains(kvp.Key))
            {
                shapes[kvp.Key] = kvp.Value;
            }
        }

        return shapes;
    }
    private bool IsBottleShapeSelected(string shape)
    {
        return string.Equals(BoteConfig.Forma, shape, StringComparison.OrdinalIgnoreCase);
    }

    private bool IsCapShapeSelected(string shape)
    {
        return string.Equals(CapConfig.Forma, shape, StringComparison.OrdinalIgnoreCase);
    }

    private async Task OnBottleShapeChange(string shape)
    {
        Console.WriteLine($"OnBottleShapeChange llamado: {shape}");

        BoteConfig.Forma = shape; // ⚡ CRÍTICO: Actualizar el modelo

        RecomputeAllFilters(); // Recalcular cascada completa
        UpdateBoteImage();     // Actualizar imagen
        UpdateCurrentDimensions(); // Actualizar dimensiones

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);

        if (IsBottleTab)
        {
            await AdjustDimensionLines();
        }
    }


    private async Task OnCapShapeChange(string shape)
    {
        Console.WriteLine($"OnCapShapeChange llamado: {shape}");

        CapConfig.Forma = shape; // ⚡ CRÍTICO: Actualizar el modelo

        RecomputeCapFilters(); // Recalcular filtros de tapa
        UpdateCapImage();      // Actualizar imagen
        UpdateCapDimensions(); // Actualizar dimensiones

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);

        if (!IsBottleTab)
        {
            await AdjustCapDimensionLines();
        }
    }
    private void RecomputeCapFilters()
    {
        Console.WriteLine($"=== INICIO RecomputeCapFilters ===");

        var diaSel = NormDiam(BoteConfig.Diametro);
        string formaCapSel = NormFormaCap(CapConfig.Forma);
        string colorCapSel = N(CapConfig.Color);

        Console.WriteLine($"Diámetro del bote (para sincronizar): '{diaSel}'");
        Console.WriteLine($"Forma de tapa seleccionada: '{formaCapSel}'");
        Console.WriteLine($"Color de tapa seleccionado: '{colorCapSel}'");

        // Filtrar por diámetro sincronizado con el bote
        var capsFiltered = (CapData ?? Enumerable.Empty<CapDataItem>())
            .Where(c => string.IsNullOrEmpty(diaSel) || NormDiam(c.Diametro) == diaSel)
            .ToList();

        Console.WriteLine($"Tapas disponibles para diámetro {diaSel}: {capsFiltered.Count}");

        // ===== FORMAS DE TAPA DISPONIBLES =====
        AvailableCapForms = new HashSet<string>(
            capsFiltered
                .Where(c => string.IsNullOrEmpty(colorCapSel) || N(c.Color) == colorCapSel)
                .Select(c => NormFormaCap(c.Forma))
                .Where(f => !string.IsNullOrEmpty(f))
                .Distinct(StringComparer.OrdinalIgnoreCase),
            StringComparer.OrdinalIgnoreCase
        );

        Console.WriteLine($"Formas de tapa disponibles: {string.Join(", ", AvailableCapForms)}");

        // Validar forma seleccionada
        if (!string.IsNullOrEmpty(formaCapSel) && !AvailableCapForms.Contains(formaCapSel))
        {
            Console.WriteLine($"Forma '{formaCapSel}' no disponible, reseteando");
            CapConfig.Forma = formaCapSel = "";
        }

        // ===== COLORES DE TAPA DISPONIBLES =====
        var colorNames = capsFiltered
            .Where(c => string.IsNullOrEmpty(formaCapSel) || NormFormaCap(c.Forma) == formaCapSel)
            .Select(c => N(c.Color))
            .Where(s => !string.IsNullOrEmpty(s))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => c, StringComparer.OrdinalIgnoreCase)
            .ToList();

        Console.WriteLine($"Colores de tapa disponibles: {string.Join(", ", colorNames)}");

        OptionsColorCoverFiltered = colorNames.Any()
            ? MapNamesToColorOptions(colorNames, OptionsColorCover ?? OptionsColorCoverUI)
            : (OptionsColorCover?.ToList() ?? OptionsColorCoverUI.ToList());

        if (!string.IsNullOrEmpty(colorCapSel) &&
            !OptionsColorCoverFiltered.Any(o =>
                string.Equals((o.Label ?? o.Value), colorCapSel, StringComparison.OrdinalIgnoreCase)))
        {
            Console.WriteLine($"Color '{colorCapSel}' no disponible, reseteando");
            CapConfig.Color = "";
        }

        UpdateCapImage();
        UpdateCapDimensions();

        Console.WriteLine($"=== FIN RecomputeCapFilters ===");
    }

    private void RecomputeAllFilters()
    {
        // Guardar valores anteriores para detectar cambios
        var oldForma = BoteConfig.Forma;
        var oldCap = BoteConfig.Capacidad;
        var oldDia = BoteConfig.Diametro;
        var oldMat = BoteConfig.Material;
        var oldColor = BoteConfig.Color;

        var oldCapForma = CapConfig.Forma;
        var oldCapColor = CapConfig.Color;

        RecomputeBottleFilters();
        RecomputeCapFilters();
        UpdateCurrentDimensions();
        UpdateBoteImage();
        UpdateCapImage();

        // Detectar si algún campo fue reseteado
        bool wasReset =
            (oldForma != BoteConfig.Forma) ||
            (oldCap != BoteConfig.Capacidad) ||
            (oldDia != BoteConfig.Diametro) ||
            (oldMat != BoteConfig.Material) ||
            (oldColor != BoteConfig.Color) ||
            (oldCapForma != CapConfig.Forma) ||
            (oldCapColor != CapConfig.Color);

        if (wasReset)
        {
            Console.WriteLine("⚠️ Algunos campos fueron reseteados por incompatibilidad");
            InvokeAsync(StateHasChanged); // Forzar refresco de UI
        }
        else
        {
            StateHasChanged();
        }
    }



    

   
    private async Task AdjustCapDimensionLines()
    {
        try
        {
            var script = $@"
        (function() {{
            // Obtener el contenedor de la tapa
            var capWrapper = document.getElementById('cap-wrapper-{ComponentId}');
            if (!capWrapper) {{
                console.log('No se encontró el contenedor de la tapa');
                return;
            }}

            // Buscar la imagen de la tapa
            var capImg = capWrapper.querySelector('img');
            if (!capImg) {{
                console.log('No se encontró imagen en el contenedor de la tapa');
                return;
            }}

            // Esperar a que la imagen esté cargada
            if (!capImg.complete) {{
                capImg.onload = function() {{
                    adjustCapDimensions();
                }};
                return;
            }}

            function adjustCapDimensions() {{
                // Obtener las dimensiones reales
                var imgRect = capImg.getBoundingClientRect();
                var wrapperRect = capWrapper.getBoundingClientRect();

                console.log('Cap image rect:', imgRect);
                console.log('Cap wrapper rect:', wrapperRect);

                // ===== LÍNEA SUPERIOR (DIÁMETRO) - CENTRADA =====
                var dimTop = capWrapper.querySelector('.cap-dimension-top');
                if (dimTop) {{
                    // Calcular el centro horizontal de la imagen
                    var imgCenterX = imgRect.left - wrapperRect.left + (imgRect.width / 2);

                    // Posicionar justo encima de la imagen y centrada
                    var topPosition = imgRect.top - wrapperRect.top - 30;
                    var leftPosition = imgCenterX - (imgRect.width / 2);

                    dimTop.style.position = 'absolute';
                    dimTop.style.top = topPosition + 'px';
                    dimTop.style.left = leftPosition + 'px';
                    dimTop.style.width = imgRect.width + 'px';
                    dimTop.style.transform = 'none'; // Quitar cualquier transform previo

                    console.log('Línea superior centrada - Left:', leftPosition, 'Width:', imgRect.width, 'Center:', imgCenterX);
                }}

                // ===== LÍNEA IZQUIERDA (ALTURA) =====
                var dimLeft = capWrapper.querySelector('.cap-dimension-left');
                if (dimLeft) {{
                    // Posicionar a la izquierda de la imagen
                    var leftPosition = imgRect.left - wrapperRect.left - 40;
                    var topPosition = imgRect.top - wrapperRect.top;

                    dimLeft.style.position = 'absolute';
                    dimLeft.style.left = leftPosition + 'px';
                    dimLeft.style.top = topPosition + 'px';
                    dimLeft.style.height = imgRect.height + 'px';

                    console.log('Línea izquierda ajustada - Left:', leftPosition, 'Height:', imgRect.height);
                }}
            }}

            // Ejecutar el ajuste
            adjustCapDimensions();

            // Re-ajustar cuando cambie el tamaño de la ventana
            window.addEventListener('resize', function() {{
                setTimeout(adjustCapDimensions, 100);
            }});
        }})();
        ";

            await JSRuntime.InvokeVoidAsync("eval", script);
        }
        catch (Exception ex)
        {
            Logger?.LogWarning("Error adjusting cap dimension lines: {Message}", ex.Message);
        }
    }

    private async Task OnBoteColorChangedAsync()
    {
        Console.WriteLine($"OnBoteColorChangedAsync - Color: {BoteConfig.Color}");

        RecomputeAllFilters(); // ⚡ AGREGAR ESTA LÍNEA
        UpdateBoteImage();

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);

        if (IsBottleTab)
        {
            await AdjustDimensionLines();
        }
    }

    private async Task OnCapColorChangedAsync()
    {
        Console.WriteLine($"OnCapColorChangedAsync - Color: {CapConfig.Color}");

        RecomputeCapFilters(); // ⚡ Recalcular filtros
        UpdateCapImage();
        UpdateCapDimensions();

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);

        if (!IsBottleTab)
        {
            await AdjustCapDimensionLines();
        }
    }
    
     
    private async Task ForceAdjustDimensions()
    {
        await InvokeAsync(StateHasChanged);
        await Task.Delay(150); // Dar tiempo al DOM para actualizarse

        if (IsBottleTab)
        {
            await AdjustDimensionLines();
        }
        else
        {
            await AdjustCapDimensionLines();
        }
    }
    // ===== Ciclo de vida =====
    protected override async Task OnParametersSetAsync()
    {
        if (string.IsNullOrWhiteSpace(BoteConfig.ImagenBote))
        {
            BoteConfig.ImagenBote = NO_IMAGE_AVAILABLE;
        }
        if (string.IsNullOrWhiteSpace(CapConfig.ImagenCap))
        {
            CapConfig.ImagenCap = NO_IMAGE_AVAILABLE;
        }
        // Inyectar lookups/colores externos si vienen
        if (Capacidades?.Any() == true) CapacidadOptionsUI = Capacidades.ToList();
        if (CapacidadToDiametros is not null) CapacidadToDiametrosUI = CapacidadToDiametros;
        if (Materiales?.Any() == true) MaterialOptionsUI = Materiales.ToList();
        if (OptionsColorBote?.Any() == true) OptionsColorBoteUI = OptionsColorBote.ToList();
        if (OptionsColorCover?.Any() == true) OptionsColorCoverUI = OptionsColorCover.ToList();
        var currentBoteImage = BoteConfig?.ImagenBote;
        var currentCapImage = CapConfig?.ImagenCap;

        // Cargar seleccionados
        if (SelectedOption != null)
        {
            BoteConfig.Forma = SelectedOption.Forma?.ToUpperInvariant() ?? "";
            BoteConfig.Capacidad = SelectedOption.Capacidad ?? "";
            BoteConfig.Diametro = SelectedOption.Diametro ?? "";
            BoteConfig.Material = SelectedOption.Material ?? "";
            BoteConfig.Color = SelectedOption.Color ?? "";
            // NO cargar la imagen desde SelectedOption si ya tenemos una calculada
            if (string.IsNullOrEmpty(currentBoteImage))
            {
                BoteConfig.ImagenBote = SelectedOption.ImagenBote ?? "";
            }
        }

        if (SelectedOptionCap != null)
        {
            CapConfig.Forma = SelectedOptionCap.Forma?.ToUpperInvariant() ?? "";
            CapConfig.Diametro = SelectedOptionCap.Diametro ?? "";
            CapConfig.Color = SelectedOptionCap.Color ?? "";
            CapConfig.Sleeve = SelectedOptionCap.Sleeve;
            // NO cargar la imagen desde SelectedOptionCap si ya tenemos una calculada
            if (string.IsNullOrEmpty(currentCapImage))
            {
                CapConfig.ImagenCap = SelectedOptionCap.ImagenCap ?? "";
            }
        }

        NormalizeForma();
        RecomputeAllFilters();
        UpdateBoteImage();
        UpdateCapImage();
        // Si aún no hay imágenes después de todo el proceso, establecer la de no disponible
        if (string.IsNullOrWhiteSpace(BoteConfig.ImagenBote))
        {
            BoteConfig.ImagenBote = NO_IMAGE_AVAILABLE;
        }
        if (string.IsNullOrWhiteSpace(CapConfig.ImagenCap))
        {
            CapConfig.ImagenCap = NO_IMAGE_AVAILABLE;
        }
        if (string.IsNullOrEmpty(SelectedBottleShape))
        {
            var availableBottleShapes = GetAvailableBottleShapes();
            if (availableBottleShapes.Any())
            {
                SelectedBottleShape = availableBottleShapes.First().Key;
            }
        }

        if (string.IsNullOrEmpty(SelectedCapShape))
        {
            var availableCapShapes = GetAvailableCapShapes();
            if (availableCapShapes.Any())
            {
                SelectedCapShape = availableCapShapes.First().Key;
            }
        }
        await base.OnParametersSetAsync();
    }

    // ===== API pública =====
    public async Task ShowModal()
    {
        IsVisible = true;
        await InvokeAsync(StateHasChanged);
        await UpdateBodyScroll();
        if (SetAccordionOpen.HasDelegate)
            await SetAccordionOpen.InvokeAsync(true);

    }

    public async Task HideModal()
    {
        IsVisible = false;
        await InvokeAsync(StateHasChanged);
        await UpdateBodyScroll();
        if (SetAccordionOpen.HasDelegate)
            await SetAccordionOpen.InvokeAsync(false);
        if (OnClose.HasDelegate)
            await OnClose.InvokeAsync();
    }

    // ===== Lógica interna =====
    private void ResetFilters()
    {
        // BOTE vacío
        BoteConfig.Forma = "";
        BoteConfig.Capacidad = "";
        BoteConfig.Diametro = "";
        BoteConfig.Material = "";
        BoteConfig.Color = "";
        BoteConfig.ImagenBote = NO_IMAGE_AVAILABLE; // Mostrar imagen de no disponible

        // TAPA vacía y sin sleeve
        CapConfig.Forma = "";
        CapConfig.Diametro = "";
        CapConfig.Color = "";
        CapConfig.Sleeve = false;
        CapConfig.ImagenCap = NO_IMAGE_AVAILABLE; // Mostrar imagen de no disponible

        RecomputeAllFilters();
    }


    private void NormalizeForma()
    {
        var f = (BoteConfig.Forma ?? "").Trim();
        if (!string.IsNullOrEmpty(f)) BoteConfig.Forma = NormFormaBote(f);

        var fc = (CapConfig.Forma ?? "").Trim();
        if (!string.IsNullOrEmpty(fc)) CapConfig.Forma = NormFormaCap(fc);
    }

    private string GetBoteHexColor()
    {
        var key = (BoteConfig.Color ?? "").Trim();
        if (key.StartsWith("#") && key.Length >= 4) return key;
        var c = OptionsColorBoteFiltered.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase))
            ?? OptionsColorBoteUI.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase));
        Console.WriteLine($"Color key: '{key}', resolved to hex: '{c?.Hex ?? c?.ColorHex ?? "#CCCCCC"}'");
        return c?.Hex ?? c?.ColorHex ?? "#CCCCCC";
    }

    private string GetCapHexColor()
    {
        var key = (CapConfig.Color ?? "").Trim();
        Console.WriteLine($"GetCapHexColor - Color seleccionado: {key}");

        if (key.StartsWith("#") && key.Length >= 4) return key;

        var c = OptionsColorCoverFiltered.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase))
            ?? OptionsColorCoverUI.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase));

        var hexColor = c?.Hex ?? c?.ColorHex ?? "#FFFFFF";
        Console.WriteLine($"GetCapHexColor - Hex resultante: {hexColor}");

        return hexColor;
    }

    private string GetAlturaText()
    {// Si no hay dimensiones cargadas, intentar cargarlas
        if (CurrentBoteDimension == null &&
            !string.IsNullOrEmpty(BoteConfig.Capacidad) &&
            !string.IsNullOrEmpty(BoteConfig.Diametro))
        {
            UpdateCurrentDimensions();
        }

        // Si hay dimensiones válidas, mostrarlas; si no, mostrar N/A
        return CurrentBoteDimension != null
            ? $"{CurrentBoteDimension.Altura:F1} mm"
            : "N/A";
    }
    private string GetDiamBaseText()
    {
        // Si no hay dimensiones cargadas, intentar cargarlas
        if (CurrentBoteDimension == null &&
            !string.IsNullOrEmpty(BoteConfig.Capacidad) &&
            !string.IsNullOrEmpty(BoteConfig.Diametro))
        {
            UpdateCurrentDimensions();
        }

        // Si hay dimensiones válidas, mostrarlas; si no, mostrar N/A
        return CurrentBoteDimension != null
            ? $"{CurrentBoteDimension.DiametroBase:F1} mm"
            : "N/A";
    }
    private string GetDiamBocaText()
    {
        if (CurrentBoteDimension == null &&
       !string.IsNullOrEmpty(BoteConfig.Capacidad) &&
       !string.IsNullOrEmpty(BoteConfig.Diametro))
        {
            UpdateCurrentDimensions();
        }

        // Si hay dimensiones válidas, mostrarlas; si no, mostrar N/A
        return CurrentBoteDimension != null
            ? $"{CurrentBoteDimension.DiametroBoca:F2} mm"
            : "N/A";
    }

     

    // ===== Tipos =====
    public sealed class ColorOption
    {
        public int ID { get; set; }
        public string Value { get; set; } = "";     // etiqueta
        public string ColorHex { get; set; } = "";  // #RRGGBB
        public string Round { get; set; } = "";
        public string Square { get; set; } = "";
        public string Cylindrical { get; set; } = "";
        public string Simple { get; set; } = "";
        public string Metal { get; set; } = "";
        public string Childproof { get; set; } = "";

        public string Label { get => Value; set => Value = value; }
        public string Hex { get => ColorHex; set => ColorHex = value; }

        public ColorOption() { }
        public ColorOption(string label, string hex) { Value = label; ColorHex = hex; }
    }

    public sealed class BoteDataItem
    {
        public string? Forma { get; set; }
        public string? Capacidad { get; set; }
        public string? Diametro { get; set; }
        public string? Material { get; set; }
        public string? Color { get; set; }
        public string? ImagenBote { get; set; }
        public string? ImagenUrl { get; set; }
        public int PesoMaximo { get; set; }
    }

    public sealed class CapDataItem
    {
        public string? Forma { get; set; }
        public string? Diametro { get; set; }
        public string? Color { get; set; }
        public bool Sleeve { get; set; }
        public string? ImagenCap { get; set; }
        public string? ImagenUrl { get; set; }
    }

    private sealed class BoteConfigModel
    {
        public string Forma { get; set; } = "";
        public string Capacidad { get; set; } = "";
        public string Diametro { get; set; } = "";
        public string Material { get; set; } = "";
        public string Color { get; set; } = "";
        public string ImagenBote { get; set; } = NO_IMAGE_AVAILABLE; // Inicializar con imagen por defecto
    }

    private sealed class CapConfigModel
    {
        public string Forma { get; set; } = "";
        public string Diametro { get; set; } = "";
        public string Color { get; set; } = "";
        public bool Sleeve { get; set; } = false;
        public string ImagenCap { get; set; } = NO_IMAGE_AVAILABLE; // Inicializar con imagen por defecto
    }

    private sealed record BoteDimension(double Altura, double DiametroBase, double DiametroBoca);
    private async Task OnCapacidadChanged()
    {
        RecomputeAllFilters();
        await InvokeAsync(StateHasChanged);
    }
    
    // Mapa sencillo para mostrar dimensiones aproximadas por capacidad/diámetro

    private static List<ColorOption> MapNamesToColorOptions(
    IEnumerable<string> names,
    IEnumerable<ColorOption> catalog)
    {
        var cat = (catalog ?? Enumerable.Empty<ColorOption>()).ToList();
        var list = new List<ColorOption>();
        int id = 1;

        foreach (var name in names)
        {
            // Intenta emparejar por Label/Value en el catálogo recibido
            var found = cat.FirstOrDefault(c =>
                string.Equals((c.Label ?? c.Value), name, StringComparison.OrdinalIgnoreCase));

            // Si no existe en el catálogo, crea una entrada con HEX de respaldo
            list.Add(found ?? new ColorOption
            {
                ID = id++,
                Value = name,
                ColorHex = ColorToHexFallback(name)
            });
        }
        return list;
    }
    private async Task SaveAsync()
    {
        if (CapacidadOptionsFiltered.Any())
        {


            IsSaving = true;
            StateHasChanged();
            try
            {
                // Valores actuales del modal
                var capacidad = BoteConfig.Capacidad ?? "";
                var boca = BoteConfig.Diametro ?? "";
                var material = BoteConfig.Material ?? "";
                var color = BoteConfig.Color ?? "";
                var forma = BoteConfig.Forma ?? "ROUND";

                var capForma = MapCapFormaToApi(CapConfig.Forma);
                var capColor = CapConfig.Color ?? "";
                var capSleeve = CapConfig.Sleeve;

                // Igual que en ContainerPackagingModal.UpdateSelectedOption()
                var data = new
                {
                    Bote_forma = forma,
                    Bote_capacidad = capacidad,
                    Bote_boca = boca,
                    Bote_color = color,
                    Bote_material = material,

                    Cap_tapa = capForma,
                    Cap_Boca = boca,       // sincronizado con el bote
                    Cap_color = capColor,
                    Cap_sleever = capSleeve,

                    Characteristics = $"{color} {capacidad}cc {material} {boca}"
                };

                Logger?.LogInformation("Saving Packaging: Size={capacidad}, Diameter={boca}", capacidad, boca);

                var url = $"CustomizeRG35('{CodeRG35}')?$expand=Formulation,Recipe,Analytics&tenant=nutris";
                var response = await ApiService.PatchAsync(url, data);

                if (!response.IsSuccessStatusCode)
                {
                    var err = await response.Content.ReadAsStringAsync();
                    Logger?.LogError("API error response: {err}", err);
                    await ShowAlert("Error actualizando datos. Inténtalo de nuevo.");
                    return;
                }

                Logger?.LogInformation("Packaging updated successfully");

                // Notifica al padre (mismo shape que el modal antiguo)
                var updated = new UpdatedOptions
                    {
                        BoteOption = new SelectedBoteOption
                        {
                            BoteForma = forma,
                            BoteCapacidad = capacidad,
                            BoteBoca = boca,
                            BoteColor = color,
                            BoteMaterial = material
                        },
                        CapOption = new SelectedCapOption
                        {
                            CapTapa = capForma,
                            CapBoca = boca,
                            CapColor = capColor,
                            CapSleever = capSleeve
                        },
                        Characteristics = data.Characteristics
                    };

                if (OnOptionsUpdated.HasDelegate)
                    await OnOptionsUpdated.InvokeAsync(updated);

                // Cierra el modal…
                await HideModal();

                // …y recarga duro (igual que el otro modal)
                Navigation.NavigateTo(Navigation.Uri, forceLoad: true);
            }
            catch (Exception ex)
            {
                Logger?.LogError(ex, "Error saving Packaging");
                await ShowAlert("Se produjo un error. Inténtalo de nuevo.");
            }
        }
    }

    private async Task ShowAlert(string message)
    {
        try { await JSRuntime.InvokeVoidAsync("alert", message); }
        catch { /* no-op */ }
    }

    private static string MapCapFormaToApi(string? forma)
    {
        // En este modal usamos "SIMPLE/METAL/CHILDPROFF".
        // La API espera "Simple/Metal/Childproof".
        switch ((forma ?? "").Trim().ToUpperInvariant())
        {
            case "SIMPLE": return "Simple";
            case "METAL": return "Metal";
            case "CHILDPROOF": return "Childproof";
            default: return forma ?? "";
        }
    }
    // ===== LAZY LOAD DE IMÁGENES =====

    private string? GetBoteImageLazy(BoteDataItem bote)
    {
        if (string.IsNullOrWhiteSpace(bote.Forma)) return NO_IMAGE_AVAILABLE;

        if (RelacionBote.ValueKind != JsonValueKind.Object) return NO_IMAGE_AVAILABLE;
        if (!RelacionBote.TryGetProperty("value", out var boteArray)) return NO_IMAGE_AVAILABLE;

        foreach (var item in boteArray.EnumerateArray())
        {
            if (TryGetStringJson(item, "Forma", out var f) && f == bote.Forma &&
                TryGetStringJson(item, "Capacidad", out var c) && c == bote.Capacidad &&
                TryGetStringJson(item, "Diametro", out var d) && d == bote.Diametro &&
                TryGetStringJson(item, "Material", out var m) && m == bote.Material &&
                TryGetStringJson(item, "Color", out var col) && col == bote.Color)
            {
                if (TryGetStringJson(item, "ImagenUrl", out var img) && !string.IsNullOrWhiteSpace(img))
                {
                    return img;
                }
            }
        }

        return NO_IMAGE_AVAILABLE;
    }

    private string? GetCapImageLazy(CapDataItem cap)
    {
        if (string.IsNullOrWhiteSpace(cap.Forma)) return NO_IMAGE_AVAILABLE;

        if (RelacionTapa.ValueKind != JsonValueKind.Object) return NO_IMAGE_AVAILABLE;
        if (!RelacionTapa.TryGetProperty("value", out var tapaArray)) return NO_IMAGE_AVAILABLE;

        foreach (var item in tapaArray.EnumerateArray())
        {
            if (TryGetStringJson(item, "Forma", out var f) && f == cap.Forma &&
                TryGetStringJson(item, "Diametro", out var d) && d == cap.Diametro &&
                TryGetStringJson(item, "Color", out var c) && c == cap.Color)
            {
                bool itemSleeve = item.TryGetProperty("Sleeve", out var slEl) && slEl.ValueKind == JsonValueKind.True;

                if (itemSleeve == cap.Sleeve)
                {
                    if (TryGetStringJson(item, "ImagenUrl", out var img) && !string.IsNullOrWhiteSpace(img))
                    {
                        return img;
                    }
                }
            }
        }

        return NO_IMAGE_AVAILABLE;
    }

    private static bool TryGetStringJson(JsonElement obj, string prop, out string value)
    {
        value = "";
        if (obj.TryGetProperty(prop, out var el))
        {
            value = el.ValueKind == JsonValueKind.String ? (el.GetString() ?? "") : el.ToString();
            return true;
        }
        return false;
    }
    private static string ColorToHexFallback(string name)
    {
        var n = (name ?? "").Trim().ToLowerInvariant();
        return n switch
        {
            "clear" => "#CCCCCC",
            "white" => "#FFFFFF",
            "black" => "#000000",
            "amber" => "#FFBF00",
            "red" => "#FF0000",
            "orange" => "#FFA500",
            "blue" or "light blue" => "#0D6EFD",
            "dark blue" => "#00008B",
            "green" or "light green" => "#90EE90",
            "emerald green" => "#50C878",
            "pale green" => "#98FB98",
            "turquoise" => "#40E0D0",
            "purple" or "violet" or "light purple" => "#800080",
            "gold" => "#D4AF37",
            "silver" => "#C0C0C0",
            _ => "#CCCCCC"
        };
    }

}
