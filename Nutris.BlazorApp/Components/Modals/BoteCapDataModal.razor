@* -------------------------------------------------------------
   BoteCapDataModal.razor — modal lateral derecho estilo Vue
   ------------------------------------------------------------- *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using System.Collections.Generic
@using System.Linq
@using NutrisBlazor.Services
@using Nutris.BlazorApp.Components.Shared.Bote
@using Nutris.BlazorApp.Components.Shared.Cover
@using NutrisBlazor.Components.Shared
@inject HttpClient Http
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject ILogger<BoteCapDataModal> Logger
<link href="css/BoteCapDataModal.css" rel="stylesheet" />

@if (IsVisible)
{
    <!-- Backdrop -->
    <div class="modal-backdrop-custom" @onclick="HideModal"></div>

    <!-- Modal Container -->
    <div class="modal-custom show">
        <div class="modal-dialog-custom">
            <div class="modal-content-custom">

                <!-- Header -->
                <div class="modal-header">
                    <h2 class="modal-title">Packaging/Envasado</h2>
                    <button type="button" class="btn-close" @onclick="HideModal">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>

                <!-- Body que contiene TODO -->
                <div class="modal-body">
                    <!-- Botón reset posicionado absolutamente -->
                    <button class="reset-filters-btn" @onclick="ResetFilters">
                        <img src="img/refresh.svg" alt="" aria-hidden="true" />
                        @Localization["modalContainer.Resetfilter"]
                    </button>

                    <!-- Tabs directamente en el body -->
                    <div class="custom-tabs">
                        <button class="nav-link @(IsBottleTab ? "active bottle-tab" : "")"
                                @onclick="() => IsBottleTab = true">
                            @Localization["modalContainer.Bottle"]
                        </button>
                        <button class="nav-link @(!IsBottleTab ? "active cap-tab" : "")"
                                @onclick="() => IsBottleTab = false">
                            @Localization["modalContainer.CAP"]
                        </button>
                    </div>

                    <!-- Contenido directamente después de las tabs -->
                    @if (IsBottleTab)
                    {
                        <!-- BOTE TAB -->
                        <div class="config-container">
                            <div class="preview-section">
                                <h3 class="section-title">
                                    @Localization["modalContainer.Characteristics"]</h3>

                                <div class="preview-content">
                                    <!-- Dimensiones verticales -->
                                    <div class="dimension-vertical" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%);">
                                        <div style="height: 280px; border-left: 1px solid #ccc; position: relative;">
                                            <span style="position: absolute; left: -50px; top: 50%; transform: translateY(-50%); font-size: 14px;">
                                                @GetAlturaText()
                                            </span>
                                        </div>
                                    </div>

                                    <div class="bottle-visual-wrapper">
                                        <!-- Dimensión superior -->
                                        <div style="position: absolute; top: 20px; width: 100%; text-align: center;">
                                            <span style="font-size: 14px;">@GetDiamBocaText()</span>
                                        </div>

                                        <!-- Botella según forma -->
                                        @switch (BoteConfig.Forma?.ToUpper())
                                        {
                                            case "ROUND":
                                                <BoteRound @key="@($"{BoteConfig.Forma}_{BoteConfig.Color}_{DateTime.Now.Ticks}")"
                                                           ColorBote="@GetBoteHexColor()" />
                                                break;
                                            case "SQUARE":
                                                <BoteSquare @key="@($"{BoteConfig.Forma}_{BoteConfig.Color}_{DateTime.Now.Ticks}")"
                                                            ColorBote="@GetBoteHexColor()" />
                                                break;
                                            case "CYLINDRICAL":
                                                <BoteCylindrical @key="@($"{BoteConfig.Forma}_{BoteConfig.Color}_{DateTime.Now.Ticks}")"
                                                                 ColorBote="@GetBoteHexColor()" />
                                                break;
                                        }

                                        <!-- Dimensión inferior -->
                                        <div style="position: absolute; bottom: 20px; width: 100%; text-align: center;">
                                            <span style="font-size: 14px;">@GetDiamBaseText()</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <!-- Forma -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Shape"]</label>
                                    <div class="segmented">
                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "ROUND" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("ROUND"))"
                                                @onclick='() => SetFormaBote("ROUND")'>
                                            <span class="radio-icon"></span> Round
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "SQUARE" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("SQUARE"))"
                                                @onclick='() => SetFormaBote("SQUARE")'>
                                            <span class="radio-icon"></span> Square
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(BoteConfig.Forma == "CYLINDRICAL" ? "active" : "")"
                                                disabled="@(!AvailableBottleForms.Contains("CYLINDRICAL"))"
                                                @onclick='() => SetFormaBote("CYLINDRICAL")'>
                                            <span class="radio-icon"></span> Cylindrical
                                        </button>

                                    </div>
                                </div>

                                <!-- Tamaño -->
                                <div class="field">
                                    <label class="form-label">
                                        @Localization["modalContainer.Size"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Capacidad"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectasize"]</option>
                                        @foreach (var cap in CapacidadOptionsFiltered)
                                        {
                                            <option value="@cap">@cap</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Diámetro -->
                                <div class="field">
                                    <label class="form-label"> @Localization["modalContainer.Diameter"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Diametro"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectadiameter"]</option>
                                        @foreach (var d in DiametroOptionsFiltered)
                                        {
                                            <option value="@d">@d</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Material -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Material"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Material"
                                                 @bind-Value:after="RecomputeAllFilters">
                                        <option value="">@Localization["modalContainer.Selectmaterial"]</option>
                                        @foreach (var m in MaterialOptionsFiltered)
                                        {
                                            <option value="@m">@m</option>
                                        }
                                    </InputSelect>
                                </div>

                                <!-- Tipo (Color) -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Color"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="BoteConfig.Color"
                                                 @bind-Value:after="StateHasChanged">
                                        <option value="">@Localization["modalContainer.Selectacolor"]</option>
                                        @foreach (var c in OptionsColorBoteFiltered)
                                        {
                                            <option value="@(c.Label ?? c.Value)">@(c.Label ?? c.Value)</option>
                                        }
                                    </InputSelect>
                                </div>


                            </div>
                        </div>
                    }
                    else
                    {
                        <!-- TAPA TAB -->
                        <div class="config-container">
                            <div class="preview-section cap-preview">
                                <h3 class="section-title">@Localization["modalLabel.Characteristics"]</h3>

                                <div class="preview-content">
                                    <div class="bottle-visual-wrapper">
                                        @{
                                            var currentCapHexColor = GetCapHexColor();
                                            var capFormaUpper = CapConfig.Forma?.ToUpper();
                                            Console.WriteLine($"Renderizando tapa: Forma={capFormaUpper}, Color={CapConfig.Color}, Hex={currentCapHexColor}");
                                        }

                                        @if (capFormaUpper == "SIMPLE")
                                        {
                                            <CoverSimple @key="@($"simple_{currentCapHexColor}_{CapConfig.Diametro}")"
                                                         ColorCover="@currentCapHexColor" />
                                        }
                                        else if (capFormaUpper == "METAL")
                                        {
                                            <CoverMetal @key="@($"metal_{currentCapHexColor}_{CapConfig.Diametro}")"
                                                        ColorCover="@currentCapHexColor" />
                                        }
                                        else if (capFormaUpper == "CHILDPROFF")
                                        {
                                            <CoverChildproff @key="@($"child_{currentCapHexColor}_{CapConfig.Diametro}")"
                                                             ColorCover="@currentCapHexColor" />
                                        }
                                    </div>
                                </div>
                            </div>

                            <div class="form-section">
                                <!-- Forma -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Shape"]</label>
                                    <div class="segmented">
                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "SIMPLE" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("SIMPLE"))"
                                                @onclick='() => SetFormaCap("SIMPLE")'>
                                            <span class="radio-icon"></span> Simple
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "METAL" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("METAL"))"
                                                @onclick='() => SetFormaCap("METAL")'>
                                            <span class="radio-icon"></span> Metal
                                        </button>

                                        <button type="button"
                                                class="segmented-item @(CapConfig.Forma == "CHILDPROFF" ? "active" : "")"
                                                disabled="@(!AvailableCapForms.Contains("CHILDPROFF"))"
                                                @onclick='() => SetFormaCap("CHILDPROFF")'>
                                            <span class="radio-icon"></span> Childproff
                                        </button>

                                    </div>
                                </div>

                                <!-- Diámetro tapa (sincronizado) -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.DiameterThread"]</label>
                                    <InputSelect class="form-select" TValue="string" @bind-Value="CapConfig.Diametro" disabled>
                                        <option value="">@Localization["modalContainer.Selectadiameter"]</option>
                                        @if (!string.IsNullOrEmpty(CapConfig.Diametro))
                                        {
                                            <option value="@CapConfig.Diametro">@CapConfig.Diametro</option>
                                        }
                                    </InputSelect>
                                    <small class="hint">Sincronizado con el bote</small>
                                </div>

                                <!-- Color tapa -->
                                <div class="field">
                                    <label class="form-label">@Localization["modalContainer.Color"]</label>
                                    <InputSelect class="form-select"
                                                 TValue="string"
                                                 @bind-Value="CapConfig.Color"
                                                 @bind-Value:after="StateHasChanged">
                                        <option value="">@Localization["modalContainer.Selectacolor"]</option>
                                        @foreach (var c in OptionsColorCoverFiltered)
                                        {
                                            <option value="@(c.Label ?? c.Value)">@(c.Label ?? c.Value)</option>
                                        }
                                    </InputSelect>
                                </div>


                                <!-- Sleeve -->
                                <div class="field">
                                    <label class="checkbox">
                                        <input type="checkbox" @bind="CapConfig.Sleeve" />
                                        <span>Sleeve</span>
                                    </label>
                                </div>

                            </div>
                        </div>
                    }
                </div>

                <!-- Footer -->
                <div class="modal-footer">
                    <button type="button" class="btn-cancel" @onclick="HideModal">@Localization["NavBar.Cancel"]</button>
                    <button type="button" class="btn-primary" @onclick="SaveAsync">@Localization["NavBar.Save"]</button>
                </div>
            </div>
        </div>
    </div>
}
<style>
    /* Ajuste fino de posición de tabs */
    .custom-tabs .nav-link:first-child {
        margin-left: 48px !important;
    }
    
</style>
@code {
    // ===== Props =====
    [Parameter] public bool IsVisible { get; set; } = false;
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnSave { get; set; }
    [Parameter] public EventCallback<(BoteDataItem Bote, CapDataItem Cap)> OnSaveData { get; set; }
    [Parameter] public EventCallback<UpdatedOptions> OnOptionsUpdated { get; set; }
    // Props de datos
    [Parameter] public string CodeRG35 { get; set; } = string.Empty;
    [Parameter] public BoteDataItem? SelectedOption { get; set; }
    [Parameter] public CapDataItem? SelectedOptionCap { get; set; }

    [Parameter] public IEnumerable<CapDataItem>? CapData { get; set; }
    [Parameter] public IEnumerable<BoteDataItem>? BoteData { get; set; }
    [Parameter] public IEnumerable<ColorOption>? OptionsColorBote { get; set; }
    [Parameter] public IEnumerable<ColorOption>? OptionsColorCover { get; set; }
    [Parameter] public IEnumerable<string>? Capacidades { get; set; }
    [Parameter] public Dictionary<string, List<string>>? CapacidadToDiametros { get; set; }
    [Parameter] public IEnumerable<string>? Materiales { get; set; }
    [Parameter] public string Characteristics { get; set; } = string.Empty;

    [Parameter] public EventCallback<bool> SetAccordionOpen { get; set; }

    [Inject] private IApiService ApiService { get; set; } = default!;
    [Inject] private ILocalizationService Localization { get; set; } = default!;
    public sealed class UpdatedOptions
    {
        public SelectedBoteOption? BoteOption { get; set; }
        public SelectedCapOption? CapOption { get; set; }
        public string Characteristics { get; set; } = "";
    }
    public sealed class SelectedCapOption
    {
        public string? CapTapa { get; set; }
        public string? CapBoca { get; set; }
        public string? CapColor { get; set; }
        public bool CapSleever { get; set; }
    }
    public sealed class SelectedBoteOption
    {
        public string? BoteForma { get; set; }
        public string? BoteCapacidad { get; set; }
        public string? BoteBoca { get; set; }
        public string? BoteColor { get; set; }
        public string? BoteMaterial { get; set; }
    }
    // Props opcionales (fallbacks externos)
 
    // Formas habilitadas según los filtros actuales
    private HashSet<string> AvailableBottleForms = new(StringComparer.OrdinalIgnoreCase);
    private HashSet<string> AvailableCapForms = new(StringComparer.OrdinalIgnoreCase);

    // ===== Estado =====
    private bool IsBottleTab { get; set; } = true;
    private BoteConfigModel BoteConfig { get; set; } = new();
    private CapConfigModel CapConfig { get; set; } = new();

    // Fallbacks UI por defecto (si no llegan datos/colores)
    private List<string> CapacidadOptionsUI { get; set; } = new();
    private Dictionary<string, List<string>> CapacidadToDiametrosUI { get; set; } = new();

    private List<string> DiametroOptionsUI { get; set; } = new();
    private List<string> MaterialOptionsUI { get; set; } = new() ;

    private List<ColorOption> OptionsColorBoteUI { get; set; } = new()
    {
        new("Clear", "#CCCCCC"), new("Amber", "#FFBF00"), new("Black", "#000000"), new("White","#FFFFFF")
    };
    private List<ColorOption> OptionsColorCoverUI { get; set; } = new()
    {
        new("White", "#FFFFFF"), new("Black", "#000000"), new("Blue", "#0D6EFD")
    };

    // ====================== NORMALIZACIONES ======================
    private static string N(string? s) => (s ?? "").Trim();
    private static string NUp(string? s) => N(s).ToUpperInvariant();

    private static string NormFormaBote(string? f)
    {
        f = NUp(f);
        return f switch
        {
            "REDONDO" => "ROUND",
            "CUADRADO" => "SQUARE",
            "CILINDRICO" or "CILÍNDRICO" or "CYL" => "CYLINDRICAL",
            "" => "ROUND",
            _ => f
        };
    }
    private static string NormFormaCap(string? f)
    {
        f = NUp(f);
        return f switch
        {
            "BASIC" => "SIMPLE",
            "METÁLICA" or "METALICA" => "METAL",
            "CHILDPROOF" or "NIÑOS" or "NINOS" => "CHILDPROFF",
            "" => "SIMPLE",
            _ => f
        };
    }
    private static string NormDiam(string? d) => NUp(d);

    // ====================== LISTAS FILTRADAS PARA LOS SELECT ======================
    private List<string> CapacidadOptionsFiltered = new();
    private List<string> DiametroOptionsFiltered = new();
    private List<string> MaterialOptionsFiltered = new();
    private List<ColorOption> OptionsColorBoteFiltered = new();
    private List<ColorOption> OptionsColorCoverFiltered = new();

    private BoteDimension? CurrentBoteDimension;

    // ====================== RECOMPUTES (CASCADA) ======================
    private void RecomputeBottleFilters()
    {
        var all = (BoteData ?? Enumerable.Empty<BoteDataItem>()).ToList();

        string forma = NormFormaBote(BoteConfig.Forma);
        string capSel = N(BoteConfig.Capacidad);
        string diaSel = NormDiam(BoteConfig.Diametro);
        string matSel = N(BoteConfig.Material);

        // Formas disponibles con los filtros no vacíos
        AvailableBottleForms = new HashSet<string>(
            all.Where(b =>
                (string.IsNullOrEmpty(capSel) || N(b.Capacidad) == capSel) &&
                (string.IsNullOrEmpty(diaSel) || NormDiam(b.Diametro) == diaSel) &&
                (string.IsNullOrEmpty(matSel) || N(b.Material) == matSel))
               .Select(b => NormFormaBote(b.Forma))
               .Distinct(StringComparer.OrdinalIgnoreCase),
            StringComparer.OrdinalIgnoreCase
        );

        // Si hay forma seleccionada pero ya no es válida, solo entonces corrige; si está vacía, déjala vacía
        if (!string.IsNullOrEmpty(forma) && !AvailableBottleForms.Contains(forma))
            BoteConfig.Forma = forma = AvailableBottleForms.FirstOrDefault() ?? "";

        // Dataset por forma (si no hay forma, usar todos)
        var dataForma = string.IsNullOrEmpty(forma)
            ? all
            : all.Where(b => NormFormaBote(b.Forma) == forma).ToList();

        // Capacidades válidas
        CapacidadOptionsFiltered = dataForma
            .Select(b => N(b.Capacidad))
            .Where(s => s != "")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => int.TryParse(c, out var n) ? n : int.MaxValue)
            .ThenBy(c => c, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (!string.IsNullOrEmpty(capSel) &&
            !CapacidadOptionsFiltered.Contains(capSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Capacidad = capSel = "";

        // Diámetros válidos (condicionados por capacidad si la hay)
        var dataCap = string.IsNullOrEmpty(capSel)
            ? dataForma
            : dataForma.Where(b => N(b.Capacidad) == capSel).ToList();

        DiametroOptionsFiltered = dataCap
            .Select(b => NormDiam(b.Diametro))
            .Where(s => s != "")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(d => d, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (!string.IsNullOrEmpty(diaSel) &&
            !DiametroOptionsFiltered.Contains(diaSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Diametro = diaSel = "";

        // Materiales válidos (condicionados por cap/diámetro si existen)
        var dataCapDia = string.IsNullOrEmpty(diaSel)
            ? dataCap
            : dataCap.Where(b => NormDiam(b.Diametro) == diaSel).ToList();

        MaterialOptionsFiltered = dataCapDia
            .Select(b => N(b.Material))
            .Where(s => s != "")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(m => m, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (!string.IsNullOrEmpty(matSel) &&
            !MaterialOptionsFiltered.Contains(matSel, StringComparer.OrdinalIgnoreCase))
            BoteConfig.Material = matSel = "";
        // ===== Colores válidos =====
        // Tomamos el conjunto más específico disponible, igual que en VUE:
        // 1) (forma, capacidad, diámetro, material)
        // 2) si material vacío -> (forma, capacidad, diámetro)
        // 3) si diámetro vacío -> (forma, capacidad)
        // 4) si capacidad vacía -> (forma)
        // 5) si forma vacía -> todo
        IEnumerable<BoteDataItem> baseSet;

        if (!string.IsNullOrEmpty(matSel) && dataCapDia.Any())
        {
            baseSet = dataCapDia.Where(b => N(b.Material) == matSel);
        }
        else if (dataCapDia.Any())
        {
            baseSet = dataCapDia;
        }
        else if (dataCap.Any())
        {
            baseSet = dataCap;
        }
        else if (dataForma.Any())
        {
            baseSet = dataForma;
        }
        else
        {
            baseSet = all;
        }

        var colorNames = baseSet
            .Select(b => N(b.Color))
            .Where(s => s != "")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => c, StringComparer.OrdinalIgnoreCase)
            .ToList();

        // Si no hay colores en catálogo de datos, no dejes la lista vacía: usa catálogo UI como fallback
        OptionsColorBoteFiltered = colorNames.Count > 0
            ? MapNamesToColorOptions(colorNames, OptionsColorBote ?? OptionsColorBoteUI)
            : (OptionsColorBote?.ToList() ?? OptionsColorBoteUI.ToList());

        // Si el color seleccionado ya no existe, vacíalo (para que se vea el placeholder)
        if (!string.IsNullOrEmpty(BoteConfig.Color) &&
            !OptionsColorBoteFiltered.Any(o => string.Equals((o.Label ?? o.Value), BoteConfig.Color, StringComparison.OrdinalIgnoreCase)))
        {
            BoteConfig.Color = "";
        }

        // ===== Sincroniza diámetro de tapa cuando exista
        CapConfig.Diametro = string.IsNullOrEmpty(BoteConfig.Diametro) ? "" : BoteConfig.Diametro;

    }

    private void RecomputeCapFilters()
    {
        var diaSel = NormDiam(BoteConfig.Diametro);

        var capsAll = (CapData ?? Enumerable.Empty<CapDataItem>())
            .Where(c => string.IsNullOrEmpty(diaSel) || NormDiam(c.Diametro) == diaSel)
            .ToList();

        AvailableCapForms = new HashSet<string>(
            capsAll.Select(c => NormFormaCap(c.Forma))
                   .Distinct(StringComparer.OrdinalIgnoreCase),
            StringComparer.OrdinalIgnoreCase
        );

        var forma = NormFormaCap(CapConfig.Forma);
        if (!string.IsNullOrEmpty(forma) && !AvailableCapForms.Contains(forma))
            CapConfig.Forma = forma = AvailableCapForms.FirstOrDefault() ?? "";

        var usable = string.IsNullOrEmpty(forma)
            ? capsAll
            : capsAll.Where(c => NormFormaCap(c.Forma) == forma).ToList();

        var colorNames = usable
            .Select(c => N(c.Color))
            .Where(s => s != "")
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(c => c, StringComparer.OrdinalIgnoreCase)
            .ToList();

        OptionsColorCoverFiltered = MapNamesToColorOptions(colorNames, OptionsColorCover ?? OptionsColorCoverUI);
        if (!string.IsNullOrEmpty(CapConfig.Color) &&
            !OptionsColorCoverFiltered.Any(o => string.Equals((o.Label ?? o.Value), CapConfig.Color, StringComparison.OrdinalIgnoreCase)))
            CapConfig.Color = "";
    }

    private void RecomputeAllFilters()
    {
        RecomputeBottleFilters();
        RecomputeCapFilters();
        StateHasChanged();
    }

   

    // ===== Handlers =====
    private void SetFormaBote(string forma) { BoteConfig.Forma = forma; RecomputeAllFilters(); }
    private void OnCapacityChanged(ChangeEventArgs e) { BoteConfig.Capacidad = e?.Value?.ToString() ?? BoteConfig.Capacidad; RecomputeAllFilters(); }
    private void OnDiametroChanged(ChangeEventArgs e) { BoteConfig.Diametro = e?.Value?.ToString() ?? BoteConfig.Diametro; RecomputeAllFilters(); }
    private void OnMaterialChanged(ChangeEventArgs e) { BoteConfig.Material = e?.Value?.ToString() ?? BoteConfig.Material; RecomputeAllFilters(); }

    private void SetFormaCap(string forma) 
    { 
        CapConfig.Forma = forma; 
        RecomputeCapFilters(); 
        InvokeAsync(StateHasChanged);
    }
    private void OnBoteColorChanged(ChangeEventArgs e)
    {
        BoteConfig.Color = e?.Value?.ToString() ?? BoteConfig.Color;
        // Forzar actualización completa
        InvokeAsync(StateHasChanged);
    }
    private async void OnCapColorChanged(ChangeEventArgs e)
    {
        CapConfig.Color = e?.Value?.ToString() ?? CapConfig.Color;

        // Log para debug
        var hexColor = GetCapHexColor();
        Console.WriteLine($"Color tapa cambiado a: {CapConfig.Color}, Hex: {hexColor}");

        // Forzar actualización asíncrona
        await InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    // ===== Ciclo de vida =====
    protected override void OnParametersSet()
    {
        // Inyectar lookups/colores externos si vienen
        if (Capacidades?.Any() == true) CapacidadOptionsUI = Capacidades.ToList();
        if (CapacidadToDiametros is not null) CapacidadToDiametrosUI = CapacidadToDiametros;
        if (Materiales?.Any() == true) MaterialOptionsUI = Materiales.ToList();
        if (OptionsColorBote?.Any() == true) OptionsColorBoteUI = OptionsColorBote.ToList();
        if (OptionsColorCover?.Any() == true) OptionsColorCoverUI = OptionsColorCover.ToList();

        // Cargar seleccionados
        if (SelectedOption != null)
        {
            BoteConfig.Forma = SelectedOption.Forma?.ToUpperInvariant() ?? "ROUND";
            BoteConfig.Capacidad = SelectedOption.Capacidad ?? "150";
            BoteConfig.Diametro = SelectedOption.Diametro ?? "D45";
            BoteConfig.Material = SelectedOption.Material ?? "PET";
            BoteConfig.Color = SelectedOption.Color ?? "Clear";
        }

        if (SelectedOptionCap != null)
        {
            CapConfig.Forma = SelectedOptionCap.Forma?.ToUpperInvariant() ?? "SIMPLE";
            CapConfig.Diametro = SelectedOptionCap.Diametro ?? "D45";
            CapConfig.Color = SelectedOptionCap.Color ?? "Black";
            CapConfig.Sleeve = SelectedOptionCap.Sleeve;
        }

        NormalizeForma();
        RecomputeAllFilters();
    }

    // ===== API pública =====
    public async Task ShowModal()
    {
        IsVisible = true;
        await InvokeAsync(StateHasChanged);
        if (SetAccordionOpen.HasDelegate)
            await SetAccordionOpen.InvokeAsync(true);
    }

    public async Task HideModal()
    {
        IsVisible = false;
        await InvokeAsync(StateHasChanged);
        if (SetAccordionOpen.HasDelegate)
            await SetAccordionOpen.InvokeAsync(false);
        if (OnClose.HasDelegate)
            await OnClose.InvokeAsync();
    }

    // ===== Lógica interna =====
    private void ResetFilters()
    {
        // BOTE vacío
        BoteConfig.Forma = "";
        BoteConfig.Capacidad = "";
        BoteConfig.Diametro = "";
        BoteConfig.Material = "";
        BoteConfig.Color = "";

        // TAPA vacía y sin sleeve
        CapConfig.Forma = "";
        CapConfig.Diametro = "";
        CapConfig.Color = "";
        CapConfig.Sleeve = false;

        RecomputeAllFilters();   // recalcula y desbloquea formas/opciones
    }


    private void NormalizeForma()
    {
        var f = (BoteConfig.Forma ?? "").Trim();
        if (!string.IsNullOrEmpty(f)) BoteConfig.Forma = NormFormaBote(f);

        var fc = (CapConfig.Forma ?? "").Trim();
        if (!string.IsNullOrEmpty(fc)) CapConfig.Forma = NormFormaCap(fc);
    }

    private string GetBoteHexColor()
    {
        var key = (BoteConfig.Color ?? "").Trim();
        if (key.StartsWith("#") && key.Length >= 4) return key;
        var c = OptionsColorBoteFiltered.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase))
            ?? OptionsColorBoteUI.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase));
        Console.WriteLine($"Color key: '{key}', resolved to hex: '{c?.Hex ?? c?.ColorHex ?? "#CCCCCC"}'");
        return c?.Hex ?? c?.ColorHex ?? "#CCCCCC";
    }

    private string GetCapHexColor()
    {
        var key = (CapConfig.Color ?? "").Trim();
        Console.WriteLine($"GetCapHexColor - Color seleccionado: {key}");

        if (key.StartsWith("#") && key.Length >= 4) return key;

        var c = OptionsColorCoverFiltered.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase))
            ?? OptionsColorCoverUI.FirstOrDefault(x =>
            string.Equals((x.Label ?? x.Value), key, StringComparison.OrdinalIgnoreCase));

        var hexColor = c?.Hex ?? c?.ColorHex ?? "#FFFFFF";
        Console.WriteLine($"GetCapHexColor - Hex resultante: {hexColor}");

        return hexColor;
    }

    private string GetAlturaText() => (CurrentBoteDimension?.Altura ?? 88.3).ToString("0.0") + " mm";
    private string GetDiamBaseText() => (CurrentBoteDimension?.DiametroBase ?? 55.3).ToString("0.0") + " mm";
    private string GetDiamBocaText() => (CurrentBoteDimension?.DiametroBoca ?? 43.82).ToString("0.00") + " mm";

    private void OnCapacityChangedCore() { /* ya no se usa; dejamos stub para compatibilidad */ }

    // ===== Tipos =====
    public sealed class ColorOption
    {
        public int ID { get; set; }
        public string Value { get; set; } = "";     // etiqueta
        public string ColorHex { get; set; } = "";  // #RRGGBB

        public string Label { get => Value; set => Value = value; }
        public string Hex { get => ColorHex; set => ColorHex = value; }

        public ColorOption() { }
        public ColorOption(string label, string hex) { Value = label; ColorHex = hex; }
    }

    public sealed class BoteDataItem
    {
        public string? Forma { get; set; }
        public string? Capacidad { get; set; }
        public string? Diametro { get; set; }
        public string? Material { get; set; }
        public string? Color { get; set; }
    }

    public sealed class CapDataItem
    {
        public string? Forma { get; set; }
        public string? Diametro { get; set; }
        public string? Color { get; set; }
        public bool Sleeve { get; set; }
    }

    private sealed class BoteConfigModel
    {
        public string Forma { get; set; } = "ROUND";
        public string Capacidad { get; set; } = "150";
        public string Diametro { get; set; } = "D45";
        public string Material { get; set; } = "PET";
        public string Color { get; set; } = "Clear";
    }

    private sealed class CapConfigModel
    {
        public string Forma { get; set; } = "SIMPLE";
        public string Diametro { get; set; } = "D45";
        public string Color { get; set; } = "Black";
        public bool Sleeve { get; set; } = false;
    }

    private sealed record BoteDimension(double Altura, double DiametroBase, double DiametroBoca);

    // Mapa sencillo para mostrar dimensiones aproximadas por capacidad/diámetro
    private readonly Dictionary<string, Dictionary<string, BoteDimension>> DimensionsMap = new()
    {
        ["150"] = new() { ["D45"] = new(88.3, 55.3, 43.82) },
        ["200"] = new() { ["D45"] = new(105.86, 60.0, 43.82) },
        ["250"] = new() { ["D45"] = new(111.3, 63.91, 43.82) },
        ["300"] = new() { ["D45"] = new(125.5, 70.0, 43.82) },
        ["400"] = new() { ["D45"] = new(140.0, 75.0, 43.82) },
        ["500"] = new() { ["D45"] = new(155.0, 80.0, 43.82) }
    };
    private static List<ColorOption> MapNamesToColorOptions(
    IEnumerable<string> names,
    IEnumerable<ColorOption> catalog)
    {
        var cat = (catalog ?? Enumerable.Empty<ColorOption>()).ToList();
        var list = new List<ColorOption>();
        int id = 1;

        foreach (var name in names)
        {
            // Intenta emparejar por Label/Value en el catálogo recibido
            var found = cat.FirstOrDefault(c =>
                string.Equals((c.Label ?? c.Value), name, StringComparison.OrdinalIgnoreCase));

            // Si no existe en el catálogo, crea una entrada con HEX de respaldo
            list.Add(found ?? new ColorOption
            {
                ID = id++,
                Value = name,
                ColorHex = ColorToHexFallback(name)
            });
        }
        return list;
    }
    private async Task SaveAsync()
    {
        try
        {
            // Valores actuales del modal
            var capacidad = BoteConfig.Capacidad ?? "";
            var boca = BoteConfig.Diametro ?? "";
            var material = BoteConfig.Material ?? "";
            var color = BoteConfig.Color ?? "";
            var forma = BoteConfig.Forma ?? "ROUND";

            var capForma = MapCapFormaToApi(CapConfig.Forma);
            var capColor = CapConfig.Color ?? "";
            var capSleeve = CapConfig.Sleeve;

            // Igual que en ContainerPackagingModal.UpdateSelectedOption()
            var data = new
            {
                Bote_forma = forma,
                Bote_capacidad = capacidad,
                Bote_boca = boca,
                Bote_color = color,
                Bote_material = material,

                Cap_tapa = capForma,
                Cap_Boca = boca,       // sincronizado con el bote
                Cap_color = capColor,
                Cap_sleever = capSleeve,

                Characteristics = $"{color} {capacidad}cc {material} {boca}"
            };

            Logger?.LogInformation("Saving Packaging: Size={capacidad}, Diameter={boca}", capacidad, boca);

            var url = $"CustomizeRG35('{CodeRG35}')?$expand=Formulation,Recipe,Analytics&tenant=nutris";
            var response = await ApiService.PatchAsync(url, data);

            if (!response.IsSuccessStatusCode)
            {
                var err = await response.Content.ReadAsStringAsync();
                Logger?.LogError("API error response: {err}", err);
                await ShowAlert("Error actualizando datos. Inténtalo de nuevo.");
                return;
            }

            Logger?.LogInformation("Packaging updated successfully");

            // Notifica al padre (mismo shape que el modal antiguo)
            var updated = new UpdatedOptions
            {
                BoteOption = new SelectedBoteOption
                {
                    BoteForma = forma,
                    BoteCapacidad = capacidad,
                    BoteBoca = boca,
                    BoteColor = color,
                    BoteMaterial = material
                },
                CapOption = new SelectedCapOption
                {
                    CapTapa = capForma,
                    CapBoca = boca,
                    CapColor = capColor,
                    CapSleever = capSleeve
                },
                Characteristics = data.Characteristics
            };

            if (OnOptionsUpdated.HasDelegate)
                await OnOptionsUpdated.InvokeAsync(updated);

            // Cierra el modal…
            await HideModal();

            // …y recarga duro (igual que el otro modal)
            Navigation.NavigateTo(Navigation.Uri, forceLoad: true);
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Error saving Packaging");
            await ShowAlert("Se produjo un error. Inténtalo de nuevo.");
        }
    }

    private async Task ShowAlert(string message)
    {
        try { await JSRuntime.InvokeVoidAsync("alert", message); }
        catch { /* no-op */ }
    }

    private static string MapCapFormaToApi(string? forma)
    {
        // En este modal usamos "SIMPLE/METAL/CHILDPROFF".
        // La API espera "Simple/Metal/Childproof".
        switch ((forma ?? "").Trim().ToUpperInvariant())
        {
            case "SIMPLE": return "Simple";
            case "METAL": return "Metal";
            case "CHILDPROFF": return "Childproof";
            default: return forma ?? "";
        }
    }

    private static string ColorToHexFallback(string name)
    {
        var n = (name ?? "").Trim().ToLowerInvariant();
        return n switch
        {
            "clear" => "#CCCCCC",
            "white" => "#FFFFFF",
            "black" => "#000000",
            "amber" => "#FFBF00",
            "red" => "#FF0000",
            "orange" => "#FFA500",
            "blue" or "light blue" => "#0D6EFD",
            "dark blue" => "#00008B",
            "green" or "light green" => "#90EE90",
            "emerald green" => "#50C878",
            "pale green" => "#98FB98",
            "turquoise" => "#40E0D0",
            "purple" or "violet" or "light purple" => "#800080",
            "gold" => "#D4AF37",
            "silver" => "#C0C0C0",
            _ => "#CCCCCC"
        };
    }

}
